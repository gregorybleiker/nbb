import { $APP, shadow$provide, $jscomp } from "./nbb_core.js";
const shadow_esm_import = function(x) { return import(x) };
var v4=function(){var a=t4;return $APP.l(a)?a:u4.v()},w4=function(a){return t4=a},x4=function(){return t4=null},z4=function(a){var b=$APP.vh(a);a=$APP.C.h(b,$APP.ao);var c=$APP.C.h(b,$APP.bo);b=$APP.C.h(b,$APP.hp);return[$APP.m.g($APP.Pg($APP.Wk.h(function(d){return $APP.O.g($APP.Ve(d))},y4.g(v4()))))," (",$APP.m.g(a),":",$APP.m.g(c),$APP.l(b)?[":",$APP.m.g(b)].join(""):null,")"].join("")},B4=function(){return $APP.Oh.h($APP.m,$APP.Xn.h(" ",$APP.Pg(A4.g(v4()))))},E4=function(a){return $APP.l(C4.g(v4()))?
D4(new $APP.G(null,2,5,$APP.I,[C4,a],null),$APP.wp.h($APP.qe,0)):null},tNa=function(a){var b=function(){var c=F4.g(v4());return $APP.l(c)?c:$APP.tl}();$APP.wx.l($APP.B(["expected:",function(){var c=G4.g(a);return b.g?b.g(c):b.call(null,c)}()]));return $APP.wx.l($APP.B(["  actual:",function(){var c=H4.g(a);return b.g?b.g(c):b.call(null,c)}()]))},vNa=function(a,b){var c="string"===typeof a.stack;c?(c=a.stack,c=null==c?null:$APP.jn(c),b=null==c?null:$APP.C.h(c,b),b=null==b?null:(0,$APP.BA)(b)):b=c;if($APP.l(b)){b=
$APP.A.j(null,0,null);a=$APP.A.j(null,1,null);c=new $APP.G(null,3,5,$APP.I,["todo",b,a],null);var d=uNa.g(v4());$APP.l(d)&&(b=$APP.ys.h(d,new $APP.G(null,2,5,$APP.I,["todo",b-1],null)),$APP.l(b)?(c=$APP.Wk,d=c.h,a=$APP.C.h(b,a-1),a=$APP.l(a)?a:$APP.Le($APP.v(b)),a=$APP.Ii(d.call(c,$APP.v(a),new $APP.G(null,3,5,$APP.I,[$APP.Sn,$APP.bo,$APP.co],null)))):a=c,c=a);a=$APP.A.j(c,0,null);b=$APP.A.j(c,1,null);c=$APP.A.j(c,2,null);return new $APP.h(null,3,[$APP.ao,a,$APP.bo,b,$APP.hp,c],null)}return new $APP.h(null,
2,[$APP.ao,a.fileName,$APP.bo,a.lineNumber],null)},J4=function(a){var b=function(){var c=$APP.Zn.g(a);switch(c instanceof $APP.F?c.ga:null){case "fail":return $APP.Tn.l($APP.B([vNa(Error(),4),a]));case "error":return $APP.Tn.l($APP.B([vNa(H4.g(a),0),a]));default:return a}}();return I4.g?I4.g(b):I4.call(null,b)},K4=function(a){if(a instanceof $APP.t){a=$APP.Le($APP.Yv.j($APP.fy(),a,!1));if($APP.l(a)){if(a instanceof $APP.mt)try{var b=$APP.q(a)}catch(c){b=null}else b=a;return $APP.l(b)?$APP.Se(b)&&
$APP.Ob($APP.st.g($APP.Ve(a)))&&$APP.Ob($APP.It.g($APP.Ve(a))):null}return null}return $APP.Se(a)},Q4=function(a,b){var c=$APP.ge(b),d=$APP.v(b);return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.cu,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.l(new $APP.D(null,L4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.qra,null,1,null),c))),null,1,null),$APP.B([new $APP.D(null,M4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Ju,null,
1,null),new $APP.D(null,d,null,1,null),$APP.B([new $APP.D(null,L4,null,1,null)])))),null,1,null)]))))),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.pm,null,1,null),new $APP.D(null,M4,null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,N4,null,1,null),new $APP.D(null,$APP.Oh.h($APP.fs,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Zn,null,1,null),new $APP.D(null,O4,null,1,null),$APP.B([new $APP.D(null,$APP.St,null,1,null),new $APP.D(null,
a,null,1,null),new $APP.D(null,G4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null),new $APP.D(null,H4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.GR,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,d,null,1,null)))),null,1,null),$APP.B([new $APP.D(null,L4,null,1,null)])))),null,1,null)]))))),null,1,null)))),null,1,null),new $APP.D(null,
$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,N4,null,1,null),new $APP.D(null,$APP.Oh.h($APP.fs,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Zn,null,1,null),new $APP.D(null,P4,null,1,null),$APP.B([new $APP.D(null,$APP.St,null,1,null),new $APP.D(null,a,null,1,null),new $APP.D(null,$APP.ao,null,1,null),new $APP.D(null,wNa,null,1,null),new $APP.D(null,$APP.bo,null,1,null),new $APP.D(null,$APP.bo.g($APP.Ve(b)),null,1,null),new $APP.D(null,G4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,
$APP.zm,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null),new $APP.D(null,H4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.qra,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,$APP.DF,null,1,null)))),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.GR,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,d,null,1,null)))),
null,1,null),$APP.B([new $APP.D(null,L4,null,1,null)])))),null,1,null)])))),null,1,null)]))))),null,1,null)))),null,1,null)])))),null,1,null),new $APP.D(null,M4,null,1,null)]))))},S4=function(a,b){return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.cu,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.h(new $APP.D(null,R4,null,1,null),new $APP.D(null,b,null,1,null))))),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.pm,null,1,null),new $APP.D(null,R4,null,
1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,N4,null,1,null),new $APP.D(null,$APP.Oh.h($APP.fs,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Zn,null,1,null),new $APP.D(null,O4,null,1,null),$APP.B([new $APP.D(null,$APP.St,null,1,null),new $APP.D(null,a,null,1,null),new $APP.D(null,G4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null),new $APP.D(null,H4,null,1,null),new $APP.D(null,R4,
null,1,null)]))))),null,1,null)))),null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,N4,null,1,null),new $APP.D(null,$APP.Oh.h($APP.fs,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Zn,null,1,null),new $APP.D(null,P4,null,1,null),$APP.B([new $APP.D(null,$APP.St,null,1,null),new $APP.D(null,a,null,1,null),new $APP.D(null,$APP.ao,null,1,null),new $APP.D(null,wNa,null,1,null),new $APP.D(null,$APP.bo,null,1,null),new $APP.D(null,$APP.bo.g($APP.Ve(b)),null,1,null),new $APP.D(null,G4,
null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null),new $APP.D(null,H4,null,1,null),new $APP.D(null,R4,null,1,null)]))))),null,1,null)))),null,1,null)])))),null,1,null),new $APP.D(null,R4,null,1,null)]))))},V4=function(a,b,c,d){a=$APP.Ve(d);var e=$APP.vh(a);a=$APP.C.h(e,$APP.ao);var f=$APP.C.h(e,$APP.bo),k=$APP.C.h(e,$APP.yS),n=$APP.C.h(e,$APP.hp);e=$APP.C.h(e,$APP.VC);return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,
$APP.lm,null,1,null),new $APP.D(null,T4.j(b,c,d),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Am,null,1,null),new $APP.D(null,$APP.fp,null,1,null),$APP.B([new $APP.D(null,xNa,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,U4,null,1,null),new $APP.D(null,$APP.Oh.h($APP.fs,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.ao,null,1,null),new $APP.D(null,a,null,1,null),$APP.B([new $APP.D(null,$APP.VC,null,1,null),new $APP.D(null,e,null,1,null),
new $APP.D(null,$APP.Zn,null,1,null),new $APP.D(null,$APP.sq,null,1,null),new $APP.D(null,$APP.hp,null,1,null),new $APP.D(null,n,null,1,null),new $APP.D(null,$APP.bo,null,1,null),new $APP.D(null,f,null,1,null),new $APP.D(null,G4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,d,null,1,null)))),null,1,null),new $APP.D(null,$APP.yS,null,1,null),new $APP.D(null,k,null,1,null),new $APP.D(null,H4,null,1,null),new $APP.D(null,xNa,null,1,null),new $APP.D(null,
$APP.St,null,1,null),new $APP.D(null,c,null,1,null)]))))),null,1,null)))),null,1,null)])))),null,1,null)]))))},yNa=function(a){return a.v?a.v():a.call(null)},W4=function(a,b){return function(c){function d(){return b.g?b.g(c):b.call(null,c)}return a.g?a.g(d):a.call(null,d)}},X4=function(a){return $APP.If.j(W4,yNa,a)},ANa=function(a,b){a=$APP.JB.g($APP.Mv.h(new $APP.nk(null,new $APP.h(null,1,[$APP.Br,null],null),null),$APP.Wk.h(function(c){return $APP.Ye(c)?$APP.Br:$APP.Lh($APP.df,c)?$APP.Po:$APP.Lh($APP.Se,
c)?$APP.pq:null},new $APP.G(null,2,5,$APP.I,[a,b],null))));a=$APP.A.j(a,0,null);b=new $APP.h(null,2,[$APP.Po,Y4,$APP.pq,zNa],null);return b.h?b.h(a,Y4):b.call(null,a,Y4)},DNa=function(a,b){return $APP.K.l($APP.aq.h(BNa,a),b,$APP.B([$APP.Pg($APP.aq.h(CNa,a))]))},ENa=function(){},FNa=function(a){return null!=a?$APP.Wd===a.hk?!0:a.Nd?!1:$APP.Vb(ENa,a):$APP.Vb(ENa,a)},HNa=function(a){return null==a?null:$APP.dr.B(a,$APP.kk,GNa,!0)},Z4=function(a,b){this.f=a;this.Pj=b;this.G=393217;this.O=0},$4=function(a){return new Z4(a,
$APP.th)},a5=function(a,b){return new $APP.G(null,2,5,$APP.I,[function(){D4.l(new $APP.G(null,1,5,$APP.I,[y4],null),$APP.Ng,$APP.B([a]));D4(new $APP.G(null,2,5,$APP.I,[C4,$APP.XI],null),$APP.qe);J4(new $APP.h(null,2,[$APP.Zn,INa,$APP.as,a],null));try{return b.v?b.v():b.call(null)}catch(d){var c=d;switch(c instanceof $APP.F?c.ga:null){case "cljs.test/async-disabled":throw"Async tests require fixtures to be specified as maps.  Testing aborted.";default:return J4(new $APP.h(null,4,[$APP.Zn,$APP.sq,$APP.St,
"Uncaught exception, not in assertion.",G4,null,H4,c],null))}}},function(){J4(new $APP.h(null,2,[$APP.Zn,JNa,$APP.as,a],null));return D4(new $APP.G(null,1,5,$APP.I,[y4],null),$APP.ge)}],null)},KNa=function(a){var b=$APP.XI.g($APP.Ve(a));return $APP.l(b)?a5(a,b):null},c5=function(a){return b5(KNa(a))},MNa=function(a){return function(){var b=a.v?a.v():a.call(null);if(FNa(b))throw LNa;return b}},h5=function(a){return $APP.Wk.h(function(b){var c=$APP.A.j(b,0,null),d=$APP.A.j(b,1,null);return function(){var e=
$APP.dl.g($APP.m.g(c)),f=$APP.sx($APP.fy(),e),k=function(){var r=$APP.C.h(f,d5);return $APP.l(r)?D4.l(new $APP.G(null,1,5,$APP.I,[e5],null),$APP.kk,$APP.B([e,$APP.q(r)])):null}(),n=function(){var r=$APP.C.h(f,f5);return $APP.l(r)?D4.l(new $APP.G(null,1,5,$APP.I,[g5],null),$APP.kk,$APP.B([e,$APP.q(r)])):null}();return HNa(function(){var r=v4(),p=$APP.ys.h(r,new $APP.G(null,2,5,$APP.I,[e5,$APP.dl.g($APP.m.g(e))],null)),y=$APP.ys.h(r,new $APP.G(null,2,5,$APP.I,[g5,$APP.dl.g($APP.m.g(e))],null)),z=ANa(p,
y),E=z instanceof $APP.F?z.ga:null;switch(E){case "async":return DNa(p,$APP.ji.l($APP.yt.h($APP.Vn.h(DNa,y),KNa),$APP.B([$APP.li.h($APP.yt.h($APP.XI,$APP.Ve),d)])));case "sync":var H=X4(y);return new $APP.G(null,1,5,$APP.I,[function(){function P(){for(var X=$APP.u(d),aa=null,ca=0,fa=0;;)if(fa<ca){var ma=aa.U(null,fa),oa=$APP.XI.g($APP.Ve(ma));$APP.l(oa)&&(oa=function(N,U,R,S,ha,na,ba){return function(){return b5(a5(ba,MNa(ha)))}}(X,aa,ca,fa,oa,oa,ma,H,z,E,r,p,y,e,f,k,n,b,c,d),H.g?H.g(oa):H.call(null,
oa));fa+=1}else{var ka=$APP.u(X);if(ka){oa=ka;if($APP.gf(oa))X=$APP.yd(oa),fa=$APP.zd(oa),aa=X,ca=$APP.Ge(X),X=fa;else{ma=$APP.v(oa);var T=$APP.XI.g($APP.Ve(ma));$APP.l(T)&&(X=function(N,U,R,S,ha,na,ba){return function(){return b5(a5(ba,MNa(ha)))}}(X,aa,ca,fa,T,T,ma,oa,ka,H,z,E,r,p,y,e,f,k,n,b,c,d),H.g?H.g(X):H.call(null,X));X=$APP.w(oa);aa=null;ca=0}fa=0}else return null}}var V=X4(p);return V.g?V.g(P):V.call(null,P)}],null);default:throw Error(["No matching clause: ",$APP.m.g(E)].join(""));}}())}},
$APP.Bl($APP.yt.h($APP.W,$APP.Ve),a))},i5=function(a){return b5($APP.K.h(h5(a),new $APP.G(null,1,5,$APP.I,[function(){var b=new $APP.h(null,2,[$APP.Zn,NNa,ONa,a],null);return I4.g?I4.g(b):I4.call(null,b)}],null)))},PNa=function(a){var b=v4(),c=$APP.sx($APP.fy(),a);return $APP.K.l(new $APP.G(null,1,5,$APP.I,[function(){null==b&&(t4=u4.v());var d=$APP.C.h(c,d5);$APP.l(d)&&D4.l(new $APP.G(null,1,5,$APP.I,[e5],null),$APP.kk,$APP.B([a,$APP.q(d)]));d=$APP.C.h(c,f5);return $APP.l(d)?D4.l(new $APP.G(null,
1,5,$APP.I,[g5],null),$APP.kk,$APP.B([a,$APP.q(d)])):null}],null),h5(function(){var d=$APP.hk($APP.sx($APP.fy(),a));d=$APP.li.h(function(e){return $APP.XI.g($APP.Ve(e))},d);return $APP.OA.h(function(e){return $APP.bo.g($APP.Ve(e))},d)}()),$APP.B([new $APP.G(null,1,5,$APP.I,[function(){return null==b?t4=null:null}],null)]))},SNa=function(a,b){return new $APP.G(null,2,5,$APP.I,[function(){t4=a;J4(new $APP.h(null,2,[$APP.Zn,QNa,$APP.W,b],null));return HNa(PNa(b))},function(){return J4(new $APP.h(null,
2,[$APP.Zn,RNa,$APP.W,b],null))}],null)},j5=function(a){return 0===P4.h(a,0)&&0===$APP.sq.h(a,0)},n5=function(a,b,c){a=$APP.Wx($APP.fy(),c);if(null==a)return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,TNa,null,1,null),new $APP.D(null,"Unable to resolve",null,1,null),$APP.B([new $APP.D(null,$APP.m.g(c),null,1,null),new $APP.D(null,"to a test function.",null,1,null)]))));if($APP.Ob($APP.XI.g($APP.Ve(a))))return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,TNa,null,1,null),new $APP.D(null,$APP.m.g(c),null,
1,null),$APP.B([new $APP.D(null,"is not a test",null,1,null)]))));a=$APP.W.g(a);return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.cu,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.h(new $APP.D(null,k5,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.g(new $APP.D(null,UNa,null,1,null)))),null,1,null))))),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,VNa,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.BP,null,1,null),new $APP.D(null,
$APP.Ii($APP.Y.g($APP.u($APP.K.g(new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Hy,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.v()))),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.XC,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.PK,null,1,null),new $APP.D(null,k5,null,1,null)))),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,WNa,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.g(new $APP.D(null,
l5,null,1,null)))),null,1,null)))),null,1,null)])))),null,1,null),new $APP.D(null,$APP.l($APP.Wx($APP.fy(),d5))?$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,m5,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.g(new $APP.D(null,e5,null,1,null))))),null,1,null),$APP.B([new $APP.D(null,$APP.UL,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,a,null,1,null)))),null,1,null),new $APP.D(null,$APP.dl.h($APP.m.g(a),"cljs-test-once-fixtures"),
null,1,null)])))):null,null,1,null),new $APP.D(null,$APP.l($APP.Wx($APP.fy(),f5))?$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,m5,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.g(new $APP.D(null,g5,null,1,null))))),null,1,null),$APP.B([new $APP.D(null,$APP.UL,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,a,null,1,null)))),null,1,null),new $APP.D(null,$APP.dl.h($APP.m.g(a),"cljs-test-each-fixtures"),null,1,null)])))):null,null,1,
null)])))),null,1,null))))),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,XNa,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.g(new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.ym,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null))))),null,1,null)))),null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.g(new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Hy,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.v()))),
null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.XC,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.PK,null,1,null),new $APP.D(null,k5,null,1,null)))),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.g(new $APP.D(null,YNa,null,1,null)))),null,1,null)])))),null,1,null)])))),null,1,null))))),null,1,null)])))),null,1,null)))),null,1,null)]))))},ZNa=new $APP.t(null,"async","async",-1603666168,null),$Na=new $APP.t(null,"test-var",
"test-var",534613154,null),aOa=new $APP.t(null,"test-symbol","test-symbol",-818080551,null),bOa=new $APP.t(null,"join-fixtures","join-fixtures",-1227879482,null),cOa=new $APP.t("sci.configs.cljs.test","use-fixtures","sci.configs.cljs.test/use-fixtures",-1878625231,null),UNa=new $APP.t("cljs.test","get-current-env","cljs.test/get-current-env",1274262302,null),dOa=new $APP.t(null,"summary","summary",2021379479,null),eOa=new $APP.t(null,"testing-vars-str","testing-vars-str",851973974,null),fOa=new $APP.t(null,
"do-report","do-report",581091811,null),m5=new $APP.t("cljs.test","update-current-env!","cljs.test/update-current-env!",-250761520,null),k5=new $APP.t(null,"env__38023__auto__","env__38023__auto__",1248859174,null),gOa=new $APP.t(null,"successful?","successful?",398154069,null),hOa=new $APP.F(null,"end-run-tests","end-run-tests",267300563),iOa=new $APP.t("sci.configs.cljs.test","do-report","sci.configs.cljs.test/do-report",316393255,null),jOa=new $APP.t("sci.configs.cljs.test","testing-vars-str",
"sci.configs.cljs.test/testing-vars-str",48435738,null),kOa=new $APP.t("cljs.test","run-all-tests","cljs.test/run-all-tests",-154085674,null),lOa=new $APP.t(null,"compose-fixtures","compose-fixtures",-228168278,null),mOa=new $APP.t(null,"update-current-env!","update-current-env!",418667870,null),nOa=new $APP.t("cljs.test","is","cljs.test/is",261278235,null),o5=new $APP.t(null,"fns","fns",-1469296983,null),oOa=new $APP.t("sci.configs.cljs.test","empty-env","sci.configs.cljs.test/empty-env",2060437882,
null),pOa=new $APP.t("cljs.test","run-tests","cljs.test/run-tests",-878084023,null),qOa=new $APP.t("sci.configs.cljs.test","try-expr","sci.configs.cljs.test/try-expr",23573368,null),xNa=new $APP.t(null,"t__37829__auto__","t__37829__auto__",-1124735875,null),rOa=new $APP.t("sci.configs.cljs.test","set-test","sci.configs.cljs.test/set-test",-480384125,null),sOa=new $APP.t("sci.configs.cljs.test","test-var-impl","sci.configs.cljs.test/test-var-impl",769399980,null),tOa=new $APP.t(null,"run-all-tests",
"run-all-tests",-1055479740,null),uOa=new $APP.t("cljs.core","doto","cljs.core/doto",-1284816239,null),vOa=new $APP.t(null,"*report-counters*","*report-counters*",406344974,null),wOa=new $APP.t("sci.configs.cljs.test","run-test","sci.configs.cljs.test/run-test",-478681890,null),xOa=new $APP.t("clojure.template","do-template","clojure.template/do-template",-1006634288,null),WNa=new $APP.t("cljs.test","set-env!","cljs.test/set-env!",-702147289,null),yOa=new $APP.t("sci.configs.cljs.test","compose-fixtures",
"sci.configs.cljs.test/compose-fixtures",-511601042,null),zOa=new $APP.t(null,"*load-tests*","*load-tests*",882394383,null),H4=new $APP.F(null,"actual","actual",107306363),AOa=new $APP.t(null,"is","is",2009660525,null),BOa=new $APP.t(null,"assert-expr","assert-expr",-1462436312,null),COa=new $APP.t("sci.configs.cljs.test","with-test","sci.configs.cljs.test/with-test",-631484984,null),DOa=new $APP.t(null,"inc-report-counter!","inc-report-counter!",1909274887,null),EOa=new $APP.t(null,"___37904__auto__",
"___37904__auto__",1249735108,null),p5=new $APP.t(null,"argv","argv",177740632,null),FOa=new $APP.t(null,"klass__37814__auto__","klass__37814__auto__",1134380122,null),GOa=new $APP.t(null,"test-vars-block","test-vars-block",-1720743025,null),Y4=new $APP.F(null,"async","async",1050769601),d5=new $APP.t(null,"cljs-test-once-fixtures","cljs-test-once-fixtures",1554034706,null),HOa=new $APP.t(null,"report-impl","report-impl",-1301090300,null),IOa=new $APP.F(null,"each","each",940016129),JOa=new $APP.t(null,
"*stack-trace-depth*","*stack-trace-depth*",-1172016436,null),wNa=new $APP.t("cljs.core","*file*","cljs.core/*file*",-838921929,null),KOa=new $APP.t("cljs.test","-async-test","cljs.test/-async-test",-1212607601,null),LOa=new $APP.t("sci.configs.cljs.test","report-impl","sci.configs.cljs.test/report-impl",-1550189064,null),MOa=new $APP.t(null,"testing-contexts-str","testing-contexts-str",-514798554,null),NOa=new $APP.t("sci.configs.cljs.test","successful?","sci.configs.cljs.test/successful?",664821273,
null),q5=new $APP.t(null,"definition","definition",441801545,null),OOa=new $APP.t(null,"m__37825__auto__","m__37825__auto__",-2145758086,null),VNa=new $APP.t("cljs.test","run-block","cljs.test/run-block",-834586193,null),POa=new $APP.t("sci.configs.cljs.test","assert-predicate","sci.configs.cljs.test/assert-predicate",-2137587061,null),QOa=new $APP.t(null,"test-vars","test-vars",411070579,null),ROa=new $APP.t("sci.configs.cljs.test","update-current-env!","sci.configs.cljs.test/update-current-env!",
686643170,null),O4=new $APP.F(null,"pass","pass",1574159993),g5=new $APP.F(null,"each-fixtures","each-fixtures",802243977),SOa=new $APP.t(null,"empty-env","empty-env",1793510582,null),TOa=new $APP.t("sci.configs.cljs.test","assert-expr","sci.configs.cljs.test/assert-expr",1492108132,null),UOa=new $APP.t("sci.configs.cljs.test","run-tests","sci.configs.cljs.test/run-tests",-1815455961,null),r5=new $APP.t(null,"sci.configs.cljs.test","sci.configs.cljs.test",-188958249,null),VOa=new $APP.t("sci.configs.cljs.test",
"deftest-","sci.configs.cljs.test/deftest-",-1194873897,null),RNa=new $APP.F(null,"end-test-ns","end-test-ns",1620675645),LNa=new $APP.F("cljs.test","async-disabled","cljs.test/async-disabled",-772095377),WOa=new $APP.t(null,"assert-predicate","assert-predicate",1886261199,null),s5=new $APP.t(null,"e__37824__auto__","e__37824__auto__",-1131502586,null),GNa=new $APP.F("cljs.test","block?","cljs.test/block?",686379965),t5=new $APP.F("cljs.test","default","cljs.test/default",-1581405322),XOa=new $APP.t(null,
"new-env","new-env",-1486390331,null),YOa=new $APP.t(null,"clear-env!","clear-env!",1985937008,null),ZOa=new $APP.t(null,"function?","function?",1729250129,null),$Oa=new $APP.t(null,"set-test","set-test",-210047801,null),aPa=new $APP.t(null,"report","report",-1260380759,null),bPa=new $APP.F("cljs.test","pprint","cljs.test/pprint",1627393641),cPa=new $APP.t(null,"thrown-with-msg?","thrown-with-msg?",1169763203,null),dPa=new $APP.t(null,"thrown?","thrown?",839971709,null),ePa=new $APP.t(null,"try-expr",
"try-expr",293516980,null),fPa=new $APP.F(null,"always-fail","always-fail",-1303875085),TNa=new $APP.t("cljs.core","*print-err-fn*","cljs.core/*print-err-fn*",1648367909,null),gPa=new $APP.t(null,"*testing-vars*","*testing-vars*",-377796452,null),hPa=new $APP.t(null,"use-fixtures","use-fixtures",-1608548619,null),iPa=new $APP.t(null,"namespaces","namespaces",196374058,null),jPa=new $APP.t("sci.configs.cljs.test","are","sci.configs.cljs.test/are",1981898620,null),kPa=new $APP.t("sci.configs.cljs.test",
"testing","sci.configs.cljs.test/testing",-1221647390,null),JNa=new $APP.F(null,"end-test-var","end-test-var",984198545),lPa=new $APP.t(null,"-async-test","-async-test",-272416711,null),N4=new $APP.t("cljs.test","do-report","cljs.test/do-report",1258077813,null),mPa=new $APP.t("sci.configs.cljs.test","join-fixtures","sci.configs.cljs.test/join-fixtures",-2033635070,null),nPa=new $APP.t(null,"*initial-report-counters*","*initial-report-counters*",1159867069,null),oPa=new $APP.t("cljs.test","test-var",
"cljs.test/test-var",639352116,null),u5=new $APP.F(null,"reporter","reporter",-805360621),v5=new $APP.t(null,"object__37815__auto__","object__37815__auto__",-809615693,null),pPa=new $APP.t(null,"testing","testing",-1492767066,null),qPa=new $APP.t(null,"deftest-","deftest-",-1456693229,null),QNa=new $APP.F(null,"begin-test-ns","begin-test-ns",-1701237033),w5=new $APP.t(null,"reporter","reporter",835170906,null),zNa=new $APP.F(null,"sync","sync",-624148946),rPa=new $APP.t(null,".-message",".-message",
-1827250821,null),y4=new $APP.F(null,"testing-vars","testing-vars",-2114769150),sPa=new $APP.t(null,"run-block","run-block",637995581,null),L4=new $APP.t(null,"values__37794__auto__","values__37794__auto__",-2059593763,null),NNa=new $APP.F(null,"end-test-vars","end-test-vars",-1394419713),CNa=new $APP.F(null,"after","after",594996914),tPa=new $APP.t(null,"deftest","deftest",938248815,null),uPa=new $APP.F(null,"end-test-all-vars","end-test-all-vars",548827253),vPa=new $APP.t("sci.configs.cljs.test",
"-async-test","sci.configs.cljs.test/-async-test",-2597507,null),G4=new $APP.F(null,"expected","expected",1583670997),R4=new $APP.t(null,"value__37801__auto__","value__37801__auto__",1177591751,null),wPa=new $APP.t("sci.configs.cljs.test","set-env!","sci.configs.cljs.test/set-env!",-1375392171,null),INa=new $APP.F(null,"begin-test-var","begin-test-var",-908571100),xPa=new $APP.t("sci.configs.cljs.test","async","sci.configs.cljs.test/async",-1878984636,null),yPa=new $APP.t(null,"run-tests","run-tests",
-1546431749,null),uNa=new $APP.F(null,"source-map","source-map",1706252311),zPa=new $APP.t("sci.configs.cljs.test","run-block","sci.configs.cljs.test/run-block",908067065,null),APa=new $APP.t("sci.configs.cljs.test","assert-any","sci.configs.cljs.test/assert-any",1006437217,null),C4=new $APP.F(null,"report-counters","report-counters",-1702609242),BPa=new $APP.t(null,"are","are",1713001856,null),CPa=new $APP.t("cljs.test","try-expr","cljs.test/try-expr",1224770602,null),DPa=new $APP.t(null,"fixtures",
"fixtures",-1644620775,null),EPa=new $APP.t(null,"get-current-env","get-current-env",1663721608,null),FPa=new $APP.t("sci.configs.cljs.test","function?","sci.configs.cljs.test/function?",2004698133,null),GPa=new $APP.t("sci.configs.cljs.test","test-vars","sci.configs.cljs.test/test-vars",144274751,null),ONa=new $APP.F(null,"vars","vars",-2046957217),x5=new $APP.t(null,"env-or-ns","env-or-ns",-1749047216,null),HPa=new $APP.t("sci.configs.cljs.test","testing-contexts-str","sci.configs.cljs.test/testing-contexts-str",
-783689878,null),IPa=new $APP.t("sci.configs.cljs.test","clear-env!","sci.configs.cljs.test/clear-env!",1178990908,null),JPa=new $APP.t(null,"test-var-impl","test-var-impl",499587560,null),KPa=new $APP.t("sci.configs.cljs.test","run-all-tests","sci.configs.cljs.test/run-all-tests",-823021768,null),LPa=new $APP.t("sci.configs.cljs.test","get-current-env","sci.configs.cljs.test/get-current-env",1943239244,null),MPa=new $APP.t("sci.configs.cljs.test","inc-report-counter!","sci.configs.cljs.test/inc-report-counter!",
1642740803,null),y5=new $APP.t(null,"env","env",-175281708,null),e5=new $APP.F(null,"once-fixtures","once-fixtures",1253947167),A4=new $APP.F(null,"testing-contexts","testing-contexts",-1485646523),NPa=new $APP.t(null,"vars","vars",-406425690,null),M4=new $APP.t(null,"result__37795__auto__","result__37795__auto__",-1227499293,null),OPa=new $APP.t("sci.configs.cljs.test","test-var","sci.configs.cljs.test/test-var",-298518554,null),z5=new $APP.t(null,"result__37816__auto__","result__37816__auto__",
1345528671,null),F4=new $APP.F(null,"formatter","formatter",-483008823),PPa=new $APP.t(null,"with-test","with-test",-899332596,null),XNa=new $APP.t("cljs.test","test-vars-block","cljs.test/test-vars-block",-257828355,null),QPa=new $APP.t("cljs.core","re-find","cljs.core/re-find",745076500,null),A5=new $APP.F(null,"author","author",2111686192),B5=new $APP.t(null,"done","done",750687339,null),U4=new $APP.t("cljs.test","report","cljs.test/report",-1933655233,null),RPa=new $APP.t("sci.configs.cljs.test",
"is","sci.configs.cljs.test/is",1207169321,null),f5=new $APP.t(null,"cljs-test-each-fixtures","cljs-test-each-fixtures",2061085390,null),SPa=new $APP.t(null,"set-env!","set-env!",-1099160431,null),C5=new $APP.t(null,"e__37820__auto__","e__37820__auto__",-123125150,null),TPa=new $APP.t("sci.configs.cljs.test","test-vars-block","sci.configs.cljs.test/test-vars-block",-1992257845,null),l5=new $APP.t("cljs.test","empty-env","cljs.test/empty-env",849387048,null),UPa=new $APP.t(null,"run-test","run-test",
-747708006,null),VPa=new $APP.t("sci.configs.cljs.test","deftest","sci.configs.cljs.test/deftest",670273323,null),BNa=new $APP.F(null,"before","before",-1633692388),YNa=new $APP.t("cljs.test","clear-env!","cljs.test/clear-env!",241475586,null),WPa=new $APP.t(null,"assert-any","assert-any",735315109,null),P4=new $APP.F(null,"fail","fail",1706214930);var D5=$APP.mV.h($APP.uO,null),E5=$APP.gV.j(zOa,!0,new $APP.h(null,1,[$APP.W,D5],null)),XPa=$APP.gV.j(JOa,null,new $APP.h(null,1,[$APP.W,D5],null)),YPa=$APP.gV.j(vOa,null,new $APP.h(null,1,[$APP.W,D5],null)),ZPa=$APP.gV.j(nPa,new $APP.h(null,4,[$APP.XI,0,O4,0,P4,0,$APP.sq,0],null),new $APP.h(null,1,[$APP.W,D5],null)),$Pa=$APP.gV.j(gPa,$APP.fe,new $APP.h(null,1,[$APP.W,D5],null)),u4=function u4(a){switch(arguments.length){case 0:return u4.v();case 1:return u4.g(arguments[0]);default:throw Error(["Invalid arity: ",
$APP.m.g(arguments.length)].join(""));}};u4.v=function(){return u4.g(t5)};u4.g=function(a){var b=new $APP.h(null,5,[C4,new $APP.h(null,4,[$APP.XI,0,O4,0,P4,0,$APP.sq,0],null),y4,$APP.fe,A4,$APP.fe,F4,$APP.tl,u5,a],null);return $APP.x.h(bPa,a)?$APP.kk.l(b,u5,t5,$APP.B([F4,$APP.by])):b};u4.o=1;var t4=null,D4=function D4(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return D4.l(arguments[0],arguments[1],2<c.length?new $APP.ce(c.slice(2),0,null):null)};
D4.l=function(a,b,c){return t4=$APP.Oh.M($APP.Rn,v4(),a,b,c)};D4.o=2;D4.A=function(a){var b=$APP.v(a),c=$APP.w(a);a=$APP.v(c);c=$APP.w(c);return this.l(b,a,c)};
var F5=function(){var a=$APP.xl.g($APP.th),b=$APP.xl.g($APP.th),c=$APP.xl.g($APP.th),d=$APP.xl.g($APP.th),e=$APP.C.j($APP.th,$APP.Bu,$APP.Hl.v?$APP.Hl.v():$APP.Hl.call(null));return new $APP.$l($APP.dl.h("sci.configs.cljs.test","report-impl"),function(f){return new $APP.G(null,2,5,$APP.I,[u5.g(v4()),$APP.Zn.g(f)],null)},$APP.fp,e,a,b,c,d)}(),I4=function(){var a=new $APP.ae(function(){return F5},LOa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.gu,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,
new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),HOa,"sci/configs/cljs/test.cljs",14,1,!0,349,355,$APP.fe,"Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.",$APP.l(F5)?F5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?
$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}();F5.ma(null,new $APP.G(null,2,5,$APP.I,[t5,O4],null),function(){return E4(O4)});F5.ma(null,new $APP.G(null,2,5,$APP.I,[t5,P4],null),function(a){E4(P4);$APP.wx.l($APP.B(["\nFAIL in",z4(a)]));$APP.u(A4.g(v4()))&&$APP.wx.l($APP.B([B4()]));var b=$APP.St.g(a);$APP.l(b)&&$APP.wx.l($APP.B([b]));return tNa(a)});
F5.ma(null,new $APP.G(null,2,5,$APP.I,[t5,$APP.sq],null),function(a){E4($APP.sq);$APP.wx.l($APP.B(["\nERROR in",z4(a)]));$APP.u(A4.g(v4()))&&$APP.wx.l($APP.B([B4()]));var b=$APP.St.g(a);$APP.l(b)&&$APP.wx.l($APP.B([b]));return tNa(a)});F5.ma(null,new $APP.G(null,2,5,$APP.I,[t5,$APP.yM],null),function(a){$APP.wx.l($APP.B(["\nRan",$APP.XI.g(a),"tests containing",O4.g(a)+P4.g(a)+$APP.sq.g(a),"assertions."]));return $APP.wx.l($APP.B([P4.g(a),"failures,",$APP.sq.g(a),"errors."]))});
F5.ma(null,new $APP.G(null,2,5,$APP.I,[t5,QNa],null),function(a){return $APP.wx.l($APP.B(["\nTesting",$APP.W.g(a).name]))});F5.ma(null,new $APP.G(null,2,5,$APP.I,[t5,RNa],null),function(){return null});F5.ma(null,new $APP.G(null,2,5,$APP.I,[t5,INa],null),function(){return null});F5.ma(null,new $APP.G(null,2,5,$APP.I,[t5,JNa],null),function(){return null});F5.ma(null,new $APP.G(null,2,5,$APP.I,[t5,uPa],null),function(){return null});F5.ma(null,new $APP.G(null,2,5,$APP.I,[t5,NNa],null),function(){return null});
var T4=function(){var a=$APP.xl.g($APP.th),b=$APP.xl.g($APP.th),c=$APP.xl.g($APP.th),d=$APP.xl.g($APP.th),e=$APP.C.j($APP.th,$APP.Bu,$APP.Hl.v?$APP.Hl.v():$APP.Hl.call(null));return new $APP.$l($APP.dl.h("sci.configs.cljs.test","assert-expr"),function(f,k,n){return null==n?fPa:$APP.of(n)?$APP.v(n):$APP.fp},$APP.fp,e,a,b,c,d)}();
T4.ma(null,fPa,function(a,b,c){a=$APP.Ve(c);var d=$APP.vh(a);a=$APP.C.h(d,$APP.ao);c=$APP.C.h(d,$APP.bo);var e=$APP.C.h(d,$APP.yS),f=$APP.C.h(d,$APP.hp);d=$APP.C.h(d,$APP.VC);return $APP.Y.g($APP.u($APP.K.h(new $APP.D(null,U4,null,1,null),new $APP.D(null,$APP.Oh.h($APP.fs,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Zn,null,1,null),new $APP.D(null,P4,null,1,null),$APP.B([new $APP.D(null,$APP.St,null,1,null),new $APP.D(null,b,null,1,null),new $APP.D(null,$APP.ao,null,1,null),new $APP.D(null,a,null,
1,null),new $APP.D(null,$APP.bo,null,1,null),new $APP.D(null,c,null,1,null),new $APP.D(null,$APP.yS,null,1,null),new $APP.D(null,e,null,1,null),new $APP.D(null,$APP.hp,null,1,null),new $APP.D(null,f,null,1,null),new $APP.D(null,$APP.VC,null,1,null),new $APP.D(null,d,null,1,null)]))))),null,1,null))))});T4.ma(null,$APP.fp,function(a,b,c){a=(a=$APP.cf(c))?K4($APP.v(c)):a;return $APP.l(a)?Q4(b,c):S4(b,c)});
T4.ma(null,$APP.eG,function(a,b,c){a=$APP.Ve(c);var d=$APP.vh(a);a=$APP.C.h(d,$APP.ao);var e=$APP.C.h(d,$APP.bo),f=$APP.C.h(d,$APP.yS),k=$APP.C.h(d,$APP.hp);d=$APP.C.h(d,$APP.VC);return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.cu,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.l(new $APP.D(null,FOa,null,1,null),new $APP.D(null,$APP.A.h(c,1),null,1,null),$APP.B([new $APP.D(null,v5,null,1,null),new $APP.D(null,$APP.A.h(c,2),null,1,null)]))))),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,
$APP.cu,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.h(new $APP.D(null,z5,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.kga,null,1,null),new $APP.D(null,FOa,null,1,null),$APP.B([new $APP.D(null,v5,null,1,null)])))),null,1,null))))),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.pm,null,1,null),new $APP.D(null,z5,null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,U4,null,1,null),new $APP.D(null,
$APP.Oh.h($APP.fs,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.ao,null,1,null),new $APP.D(null,a,null,1,null),$APP.B([new $APP.D(null,$APP.VC,null,1,null),new $APP.D(null,d,null,1,null),new $APP.D(null,$APP.Zn,null,1,null),new $APP.D(null,O4,null,1,null),new $APP.D(null,$APP.hp,null,1,null),new $APP.D(null,k,null,1,null),new $APP.D(null,$APP.bo,null,1,null),new $APP.D(null,e,null,1,null),new $APP.D(null,G4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),
new $APP.D(null,c,null,1,null)))),null,1,null),new $APP.D(null,$APP.yS,null,1,null),new $APP.D(null,f,null,1,null),new $APP.D(null,H4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.Lu,null,1,null),new $APP.D(null,v5,null,1,null)))),null,1,null),new $APP.D(null,$APP.St,null,1,null),new $APP.D(null,b,null,1,null)]))))),null,1,null)))),null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,U4,null,1,null),new $APP.D(null,$APP.Oh.h($APP.fs,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,
$APP.ao,null,1,null),new $APP.D(null,a,null,1,null),$APP.B([new $APP.D(null,$APP.VC,null,1,null),new $APP.D(null,d,null,1,null),new $APP.D(null,$APP.Zn,null,1,null),new $APP.D(null,P4,null,1,null),new $APP.D(null,$APP.hp,null,1,null),new $APP.D(null,k,null,1,null),new $APP.D(null,$APP.bo,null,1,null),new $APP.D(null,e,null,1,null),new $APP.D(null,G4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null),new $APP.D(null,
$APP.yS,null,1,null),new $APP.D(null,f,null,1,null),new $APP.D(null,H4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.Lu,null,1,null),new $APP.D(null,v5,null,1,null)))),null,1,null),new $APP.D(null,$APP.St,null,1,null),new $APP.D(null,b,null,1,null)]))))),null,1,null)))),null,1,null)])))),null,1,null),new $APP.D(null,z5,null,1,null)])))),null,1,null)]))))});
T4.ma(null,dPa,function(a,b,c){a=$APP.Ve(c);var d=$APP.vh(a);a=$APP.C.h(d,$APP.ao);var e=$APP.C.h(d,$APP.bo),f=$APP.C.h(d,$APP.yS),k=$APP.C.h(d,$APP.hp);d=$APP.C.h(d,$APP.VC);var n=$APP.Le(c),r=$APP.Ig(c,2);return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.lm,null,1,null),r,$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,U4,null,1,null),new $APP.D(null,$APP.Oh.h($APP.fs,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.ao,null,1,null),new $APP.D(null,a,null,1,null),$APP.B([new $APP.D(null,
$APP.VC,null,1,null),new $APP.D(null,d,null,1,null),new $APP.D(null,$APP.Zn,null,1,null),new $APP.D(null,P4,null,1,null),new $APP.D(null,$APP.hp,null,1,null),new $APP.D(null,k,null,1,null),new $APP.D(null,$APP.bo,null,1,null),new $APP.D(null,e,null,1,null),new $APP.D(null,G4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null),new $APP.D(null,$APP.yS,null,1,null),new $APP.D(null,f,null,1,null),new $APP.D(null,H4,
null,1,null),new $APP.D(null,null,null,1,null),new $APP.D(null,$APP.St,null,1,null),new $APP.D(null,b,null,1,null)]))))),null,1,null)))),null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Am,null,1,null),new $APP.D(null,n,null,1,null),$APP.B([new $APP.D(null,C5,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,U4,null,1,null),new $APP.D(null,$APP.Oh.h($APP.fs,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.ao,null,1,null),new $APP.D(null,a,null,1,null),$APP.B([new $APP.D(null,
$APP.VC,null,1,null),new $APP.D(null,d,null,1,null),new $APP.D(null,$APP.Zn,null,1,null),new $APP.D(null,O4,null,1,null),new $APP.D(null,$APP.hp,null,1,null),new $APP.D(null,k,null,1,null),new $APP.D(null,$APP.bo,null,1,null),new $APP.D(null,e,null,1,null),new $APP.D(null,G4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null),new $APP.D(null,$APP.yS,null,1,null),new $APP.D(null,f,null,1,null),new $APP.D(null,H4,
null,1,null),new $APP.D(null,C5,null,1,null),new $APP.D(null,$APP.St,null,1,null),new $APP.D(null,b,null,1,null)]))))),null,1,null)))),null,1,null),new $APP.D(null,C5,null,1,null)])))),null,1,null)]))))});
T4.ma(null,cPa,function(a,b,c){a=$APP.Ve(c);var d=$APP.vh(a);a=$APP.C.h(d,$APP.ao);var e=$APP.C.h(d,$APP.bo),f=$APP.C.h(d,$APP.yS),k=$APP.C.h(d,$APP.hp);d=$APP.C.h(d,$APP.VC);var n=$APP.A.h(c,1),r=$APP.A.h(c,2),p=$APP.Ig(c,3);return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.lm,null,1,null),p,$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,U4,null,1,null),new $APP.D(null,$APP.Oh.h($APP.fs,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.ao,null,1,null),new $APP.D(null,a,null,1,null),
$APP.B([new $APP.D(null,$APP.VC,null,1,null),new $APP.D(null,d,null,1,null),new $APP.D(null,$APP.Zn,null,1,null),new $APP.D(null,P4,null,1,null),new $APP.D(null,$APP.hp,null,1,null),new $APP.D(null,k,null,1,null),new $APP.D(null,$APP.bo,null,1,null),new $APP.D(null,e,null,1,null),new $APP.D(null,G4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null),new $APP.D(null,$APP.yS,null,1,null),new $APP.D(null,f,null,1,null),
new $APP.D(null,H4,null,1,null),new $APP.D(null,null,null,1,null),new $APP.D(null,$APP.St,null,1,null),new $APP.D(null,b,null,1,null)]))))),null,1,null)))),null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Am,null,1,null),new $APP.D(null,n,null,1,null),$APP.B([new $APP.D(null,s5,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.cu,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.h(new $APP.D(null,OOa,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,
rPa,null,1,null),new $APP.D(null,s5,null,1,null)))),null,1,null))))),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.pm,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,QPa,null,1,null),new $APP.D(null,r,null,1,null),$APP.B([new $APP.D(null,OOa,null,1,null)])))),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,U4,null,1,null),new $APP.D(null,$APP.Oh.h($APP.fs,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.ao,null,
1,null),new $APP.D(null,a,null,1,null),$APP.B([new $APP.D(null,$APP.VC,null,1,null),new $APP.D(null,d,null,1,null),new $APP.D(null,$APP.Zn,null,1,null),new $APP.D(null,O4,null,1,null),new $APP.D(null,$APP.hp,null,1,null),new $APP.D(null,k,null,1,null),new $APP.D(null,$APP.bo,null,1,null),new $APP.D(null,e,null,1,null),new $APP.D(null,G4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null),new $APP.D(null,$APP.yS,
null,1,null),new $APP.D(null,f,null,1,null),new $APP.D(null,H4,null,1,null),new $APP.D(null,s5,null,1,null),new $APP.D(null,$APP.St,null,1,null),new $APP.D(null,b,null,1,null)]))))),null,1,null)))),null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,U4,null,1,null),new $APP.D(null,$APP.Oh.h($APP.fs,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.ao,null,1,null),new $APP.D(null,a,null,1,null),$APP.B([new $APP.D(null,$APP.VC,null,1,null),new $APP.D(null,d,null,1,null),new $APP.D(null,
$APP.Zn,null,1,null),new $APP.D(null,P4,null,1,null),new $APP.D(null,$APP.hp,null,1,null),new $APP.D(null,k,null,1,null),new $APP.D(null,$APP.bo,null,1,null),new $APP.D(null,e,null,1,null),new $APP.D(null,G4,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null),new $APP.D(null,$APP.yS,null,1,null),new $APP.D(null,f,null,1,null),new $APP.D(null,H4,null,1,null),new $APP.D(null,s5,null,1,null),new $APP.D(null,$APP.St,
null,1,null),new $APP.D(null,b,null,1,null)]))))),null,1,null)))),null,1,null)])))),null,1,null),new $APP.D(null,s5,null,1,null)])))),null,1,null)])))),null,1,null)]))))});var G5=function G5(a){switch(arguments.length){case 3:return G5.j(arguments[0],arguments[1],arguments[2]);case 4:return G5.B(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.g(arguments.length-2)].join(""));}};
G5.j=function(a,b,c){return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,nOa,null,1,null),new $APP.D(null,c,null,1,null),$APP.B([new $APP.D(null,null,null,1,null)]))))};G5.B=function(a,b,c,d){return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,CPa,null,1,null),new $APP.D(null,d,null,1,null),$APP.B([new $APP.D(null,c,null,1,null)]))))};G5.o=4;
var H5=function H5(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return H5.l(arguments[0],arguments[1],arguments[2],arguments[3],4<c.length?new $APP.ce(c.slice(4),0,null):null)};
H5.l=function(a,b,c,d,e){if($APP.Ye(c)&&$APP.Ye(e)||0<$APP.Ge(c)&&0<$APP.Ge(e)&&0===$APP.hg($APP.Ge(e),$APP.Ge(c)))return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,xOa,null,1,null),new $APP.D(null,c,null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,nOa,null,1,null),new $APP.D(null,d,null,1,null)))),null,1,null),e]))));throw Error("The number of args doesn't match are's argv.");};H5.o=4;
H5.A=function(a){var b=$APP.v(a),c=$APP.w(a);a=$APP.v(c);var d=$APP.w(c);c=$APP.v(d);var e=$APP.w(d);d=$APP.v(e);e=$APP.w(e);return this.l(b,a,c,d,e)};var I5=function I5(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return I5.l(arguments[0],arguments[1],arguments[2],3<c.length?new $APP.ce(c.slice(3),0,null):null)};
I5.l=function(a,b,c,d){return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.om,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,m5,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.g(new $APP.D(null,A4,null,1,null))))),null,1,null),$APP.B([new $APP.D(null,$APP.HR,null,1,null),new $APP.D(null,c,null,1,null)])))),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.lm,null,1,null),d,$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,
$APP.mm,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,m5,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.g(new $APP.D(null,A4,null,1,null))))),null,1,null),$APP.B([new $APP.D(null,$APP.YI,null,1,null)])))),null,1,null)))),null,1,null)])))),null,1,null)]))))};I5.o=3;I5.A=function(a){var b=$APP.v(a),c=$APP.w(a);a=$APP.v(c);var d=$APP.w(c);c=$APP.v(d);d=$APP.w(d);return this.l(b,a,c,d)};
var J5=function J5(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return J5.l(arguments[0],arguments[1],arguments[2],3<c.length?new $APP.ce(c.slice(3),0,null):null)};
J5.l=function(a,b,c,d){return $APP.l($APP.q(E5))?$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,uOa,null,1,null),new $APP.D(null,c,null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.kR,null,1,null),new $APP.D(null,$APP.UL,null,1,null),$APP.B([new $APP.D(null,$APP.XI,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Hy,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.v()))),null,1,null),$APP.B([d])))),null,1,null)])))),null,1,null)])))):
c};J5.o=3;J5.A=function(a){var b=$APP.v(a),c=$APP.w(a);a=$APP.v(c);var d=$APP.w(c);c=$APP.v(d);d=$APP.w(d);return this.l(b,a,c,d)};var K5=function K5(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return K5.l(arguments[0],arguments[1],arguments[2],3<c.length?new $APP.ce(c.slice(3),0,null):null)};
K5.l=function(a,b,c,d){return $APP.l($APP.q(E5))?$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Cm,null,1,null),new $APP.D(null,$APP.dr.B(c,$APP.kk,$APP.XI,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Hy,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.v()))),null,1,null),$APP.B([d]))))),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Hy,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.v()))),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,
oPa,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.ym,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null)))),null,1,null)])))),null,1,null)])))):null};K5.o=3;K5.A=function(a){var b=$APP.v(a),c=$APP.w(a);a=$APP.v(c);var d=$APP.w(c);c=$APP.v(d);d=$APP.w(d);return this.l(b,a,c,d)};
var L5=function L5(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return L5.l(arguments[0],arguments[1],arguments[2],3<c.length?new $APP.ce(c.slice(3),0,null):null)};
L5.l=function(a,b,c,d){return $APP.l($APP.q(E5))?$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Cm,null,1,null),new $APP.D(null,$APP.dr.ea(c,$APP.kk,$APP.XI,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Hy,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.v()))),null,1,null),$APP.B([d])))),$APP.tx,!0),null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Hy,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.v()))),null,1,null),$APP.B([new $APP.D(null,
$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,OPa,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.ym,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null)))),null,1,null)])))),null,1,null)])))):null};L5.o=3;L5.A=function(a){var b=$APP.v(a),c=$APP.w(a);a=$APP.v(c);var d=$APP.w(c);c=$APP.v(d);d=$APP.w(d);return this.l(b,a,c,d)};
var M5=function M5(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return M5.l(arguments[0],arguments[1],arguments[2],3<c.length?new $APP.ce(c.slice(3),0,null):null)};
M5.l=function(a,b,c,d){return $APP.l($APP.q(E5))?$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.kR,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.ym,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null),$APP.B([new $APP.D(null,$APP.UL,null,1,null),new $APP.D(null,$APP.XI,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Hy,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.v()))),null,1,null),$APP.B([d])))),null,1,null)])))):null};
M5.o=3;M5.A=function(a){var b=$APP.v(a),c=$APP.w(a);a=$APP.v(c);var d=$APP.w(c);c=$APP.v(d);d=$APP.w(d);return this.l(b,a,c,d)};
var b5=function b5(a){for(;;){var c=$APP.u(a);if(c){var d=c,e=$APP.v(d),f=e.v?e.v():e.call(null);if(FNa(f)){var k=function(){return function(n,r){return function(){return $APP.kd(r)?$APP.wx.l($APP.B(["WARNING: Async test called done more than one time."])):$APP.q(r)}}(a,new $APP.il(function(n){return function(){var r=$APP.ge(n);return b5.g?b5.g(r):b5.call(null,r)}}(a,f,e,d,c),null),f,e,d,c)}();return f.g?f.g(k):f.call(null,k)}a=function(){var n=$APP.ge(a);return $APP.l(GNa.g($APP.Ve(f)))?$APP.K.h(f,
n):n}()}else return null}},N5=function N5(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return N5.l(arguments[0],arguments[1],arguments[2],3<c.length?new $APP.ce(c.slice(3),0,null):null)};
N5.l=function(a,b,c,d){return $APP.Y.g($APP.u($APP.K.h(new $APP.D(null,KOa,null,1,null),new $APP.D(null,$APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Hy,null,1,null),new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.h(new $APP.D(null,EOa,null,1,null),new $APP.D(null,c,null,1,null))))),null,1,null),$APP.B([d])))),null,1,null))))};N5.o=3;N5.A=function(a){var b=$APP.v(a),c=$APP.w(a);a=$APP.v(c);var d=$APP.w(c);c=$APP.v(d);d=$APP.w(d);return this.l(b,a,c,d)};$APP.g=Z4.prototype;
$APP.g.V=function(a,b){return new Z4(this.f,b)};$APP.g.T=function(){return this.Pj};$APP.g.hk=$APP.Wd;$APP.g.call=function(a){switch(arguments.length-1){case 1:return this.g(arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.g(arguments.length-1)].join(""));}};$APP.g.apply=function(a,b){return this.call.apply(this,[this].concat($APP.$b(b)))};$APP.g.g=function(a){return this.f.h?this.f.h(this,a):this.f.call(null,this,a)};
var aQa=function(){var a=new $APP.ae(function(){return c5},sOa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),JPa,"sci/configs/cljs/test.cljs",20,1,913,913,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.SN],null)),"If v has a function in its :test metadata, calls that function,\n  add v to :testing-vars property of env.",$APP.l(c5)?c5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?
$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),O5=function O5(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return O5.l(arguments[0],1<c.length?new $APP.ce(c.slice(1),0,null):null)};
O5.l=function(a,b){var c=!$APP.df(a),d=c?u4.v():a,e=$APP.$h(new $APP.h(null,5,[$APP.XI,0,O4,0,P4,0,$APP.sq,0,$APP.Zn,$APP.yM],null));return $APP.K.h($APP.ji.l(function(f){return $APP.K.h(SNa(d,f),new $APP.G(null,1,5,$APP.I,[function(){var k=e.Zb,n=$APP.Vn.h($APP.yx,$APP.RA),r=e.wa(null),p=C4.g,y=v4();t4=null;return k.call(e,null,n(r,p.call(C4,y)))}],null))},$APP.B([c?$APP.K.h(new $APP.G(null,1,5,$APP.I,[a],null),b):b])),new $APP.G(null,1,5,$APP.I,[function(){t4=d;J4($APP.q(e));var f=$APP.kk.j($APP.q(e),
$APP.Zn,hOa);I4.g?I4.g(f):I4.call(null,f);return t4=null}],null))};O5.o=1;O5.A=function(a){var b=$APP.v(a);a=$APP.w(a);return this.l(b,a)};var P5=function P5(a){switch(arguments.length){case 0:return P5.v();case 1:return P5.g(arguments[0]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return P5.l(arguments[0],1<c.length?new $APP.ce(c.slice(1),0,null):null)}};P5.v=function(){return P5.l(u4.v(),$APP.B([$APP.dl.g($APP.m.g($APP.q($APP.Xt)))]))};
P5.g=function(a){return $APP.df(a)?P5.l(a,$APP.B([$APP.dl.g($APP.m.g($APP.q($APP.Xt)))])):P5.l(u4.v(),$APP.B([a]))};P5.l=function(a,b){return b5($APP.Oh.j(O5,a,b))};P5.A=function(a){var b=$APP.v(a);a=$APP.w(a);return this.l(b,a)};P5.o=1;
var Q5=function Q5(a){switch(arguments.length){case 2:return Q5.h(arguments[0],arguments[1]);case 3:return Q5.j(arguments[0],arguments[1],arguments[2]);case 4:return Q5.B(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.g(arguments.length-2)].join(""));}};
Q5.h=function(){return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,kOa,null,1,null),new $APP.D(null,null,null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.g(new $APP.D(null,l5,null,1,null)))),null,1,null)]))))};Q5.j=function(a,b,c){return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,kOa,null,1,null),new $APP.D(null,c,null,1,null),$APP.B([new $APP.D(null,$APP.Y.g($APP.u($APP.K.g(new $APP.D(null,l5,null,1,null)))),null,1,null)]))))};
Q5.B=function(a,b,c,d){return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,pOa,null,1,null),new $APP.D(null,d,null,1,null),$APP.B([$APP.Wk.h(function(e){return $APP.Y.g($APP.u($APP.K.h(new $APP.D(null,$APP.zm,null,1,null),new $APP.D(null,e,null,1,null))))},function(){var e=$APP.Lx($APP.fy(),$APP.J($APP.GL));return $APP.l(c)?$APP.li.h(function(f){return $APP.Kk(c,$APP.xk(f.name))},e):e}())]))))};Q5.o=4;
var R5=function R5(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return R5.l(arguments[0],arguments[1],arguments[2],3<c.length?new $APP.ce(c.slice(3),0,null):null)};
R5.l=function(a,b,c,d){if($APP.l($APP.x.h?$APP.x.h($APP.dO,c):$APP.x.call(null,$APP.dO,c)))return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Cm,null,1,null),new $APP.D(null,d5,null,1,null),$APP.B([new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.g(d)))),null,1,null)]))));if($APP.l($APP.x.h?$APP.x.h(IOa,c):$APP.x.call(null,IOa,c)))return $APP.Y.g($APP.u($APP.K.l(new $APP.D(null,$APP.Cm,null,1,null),new $APP.D(null,f5,null,1,null),$APP.B([new $APP.D(null,$APP.Ii($APP.Y.g($APP.u($APP.K.g(d)))),null,
1,null)]))));if($APP.l($APP.x.h?$APP.x.h($APP.FE,c):$APP.x.call(null,$APP.FE,c)))throw Error("First argument to cljs.test/use-fixtures must be :once or :each");throw Error(["No matching clause: ",$APP.m.g(c)].join(""));};R5.o=3;R5.A=function(a){var b=$APP.v(a),c=$APP.w(a);a=$APP.v(c);var d=$APP.w(c);c=$APP.v(d);d=$APP.w(d);return this.l(b,a,c,d)};F5.ma(null,new $APP.G(null,2,5,$APP.I,[t5,hOa],null),function(a){return j5(a)?null:process.exitCode=1});
var bQa=function(){var a=new $APP.ae(function(){return T4},TOa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),BOa,"sci/configs/cljs/test.cljs",22,1,533,533,$APP.fe,null,$APP.l(T4)?T4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),cQa=$APP.Rj([zOa,JOa,WOa,QOa,WPa,gPa,SPa,pPa,BPa,nPa,ZNa,eOa,hPa,YOa,gOa,sPa,mOa,AOa,SOa,lOa,fOa,EPa,qPa,ZOa,PPa,
ePa,MOa,GOa,DOa,$Na,tPa,BOa,yPa,tOa,vOa,UPa,aPa,$Oa,$APP.us,lPa,bOa],[E5,XPa,function(){var a=new $APP.ae(function(){return Q4},POa,$APP.Rj([$APP.aG,$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],["1.1",$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),WOa,"sci/configs/cljs/test.cljs",23,1,489,489,$APP.J(new $APP.G(null,2,5,$APP.I,[$APP.pQ,$APP.KM],null)),"Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).",$APP.l(Q4)?Q4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=
new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return i5},GPa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",
$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),QOa,"sci/configs/cljs/test.cljs",16,1,969,969,$APP.J(new $APP.G(null,1,5,$APP.I,[NPa],null)),"Groups vars by their namespace and runs test-vars on them with\n  appropriate fixtures assuming they are present in the current\n  testing environment.",$APP.l(i5)?i5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);
return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return S4},APa,$APP.Rj([$APP.aG,$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],["1.1",$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),WPa,"sci/configs/cljs/test.cljs",17,1,510,510,$APP.J(new $APP.G(null,2,5,$APP.I,[$APP.pQ,$APP.KM],null)),"Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.",$APP.l(S4)?S4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?
$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),$Pa,function(){var a=new $APP.ae(function(){return w4},wPa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),SPa,"sci/configs/cljs/test.cljs",15,1,313,313,$APP.J(new $APP.G(null,1,5,$APP.I,[XOa],null)),null,$APP.l(w4)?w4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return I5},kPa,$APP.Rj([$APP.aG,
$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.yO,$APP.hp,$APP.bo,$APP.st,$APP.yS,$APP.Z,$APP.M,$APP.XI],["1.1",$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),pPa,"sci/configs/cljs/test.cljs",22,new $APP.h(null,6,[$APP.xD,!0,$APP.tw,1,$APP.VQ,1,$APP.mQ,$APP.J($APP.J($APP.aS,$APP.UE)),$APP.Z,$APP.J(new $APP.G(null,3,5,$APP.I,[$APP.aS,$APP.jm,$APP.UE],null)),$APP.RI,$APP.J(null)],null),1,708,!0,708,$APP.J(new $APP.G(null,3,5,$APP.I,[$APP.aS,$APP.jm,$APP.UE],null)),"Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).",$APP.l(I5)?I5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:
$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return H5},jPa,$APP.Rj([$APP.aG,$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.yO,$APP.hp,$APP.bo,$APP.st,$APP.yS,$APP.Z,$APP.M,$APP.XI],["1.1",$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",
$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),BPa,"sci/configs/cljs/test.cljs",18,new $APP.h(null,6,[$APP.xD,!0,$APP.tw,2,$APP.VQ,2,$APP.mQ,$APP.J($APP.J(p5,$APP.nF,$APP.BG)),$APP.Z,$APP.J(new $APP.G(null,4,5,$APP.I,[p5,$APP.nF,$APP.jm,$APP.BG],null)),$APP.RI,$APP.J(null)],null),1,683,!0,683,$APP.J(new $APP.G(null,4,5,$APP.I,[p5,$APP.nF,$APP.jm,$APP.BG],null)),"Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (\x3d x y)\n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to:\n           (do (is (\x3d 2 (+ 1 1)))\n               (is (\x3d 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.",
$APP.l(H5)?H5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),ZPa,function(){var a=new $APP.ae(function(){return N5},xPa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.yO,$APP.hp,$APP.bo,$APP.st,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,
3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),ZNa,"sci/configs/cljs/test.cljs",20,new $APP.h(null,6,[$APP.xD,!0,$APP.tw,1,$APP.VQ,1,$APP.mQ,$APP.J($APP.J(B5,$APP.UE)),$APP.Z,$APP.J(new $APP.G(null,3,5,$APP.I,[B5,$APP.jm,$APP.UE],null)),$APP.RI,$APP.J(null)],null),1,860,!0,860,$APP.J(new $APP.G(null,3,5,$APP.I,[B5,$APP.jm,$APP.UE],null)),"Wraps body as a CPS function that can be returned from a test to\n  continue asynchronously.  Binds done to a function that must be\n  invoked once and from an async context after any assertions.\n  (deftest example-with-timeout\n    (async done\n      (js/setTimeout (fn []\n                       ;; make assertions in async context...\n                       (done) ;; ...then call done\n                       )\n                     0)))",
$APP.l(N5)?N5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return z4},jOa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",
$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),eOa,"sci/configs/cljs/test.cljs",23,1,326,326,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.LN],null)),"Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion.",$APP.l(z4)?z4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);
return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return R5},cOa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.yO,$APP.hp,$APP.bo,$APP.st,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),hPa,"sci/configs/cljs/test.cljs",27,new $APP.h(null,6,[$APP.xD,!0,$APP.tw,1,$APP.VQ,1,$APP.mQ,$APP.J($APP.J($APP.XH,o5)),$APP.Z,$APP.J(new $APP.G(null,3,5,$APP.I,[$APP.XH,$APP.jm,o5],null)),$APP.RI,$APP.J(null)],null),1,1082,!0,1082,$APP.J(new $APP.G(null,3,5,$APP.I,[$APP.XH,$APP.jm,o5],null)),null,$APP.l(R5)?R5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?
$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return x4},IPa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),YOa,"sci/configs/cljs/test.cljs",17,1,316,316,$APP.J($APP.oi),null,$APP.l(x4)?x4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return j5},NOa,$APP.Rj([$APP.aG,$APP.W,$APP.O,$APP.ao,$APP.VC,
$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],["1.1",$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),gOa,"sci/configs/cljs/test.cljs",18,1,1094,1094,$APP.J(new $APP.G(null,1,5,$APP.I,[dOa],null)),"Returns true if the given test summary indicates all tests\n  were successful, false otherwise.",$APP.l(j5)?j5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,
d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return b5},zPa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),sPa,"sci/configs/cljs/test.cljs",16,1,835,835,$APP.J(new $APP.G(null,1,5,$APP.I,[o5],null)),"Invoke all functions in fns with no arguments. A fn can optionally\n  return\n  an async test - is invoked with a continuation running left fns\n  a seq of fns tagged per block - are invoked immediately after fn",$APP.l(b5)?b5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?
$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return D4},ROa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.yO,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),mOa,"sci/configs/cljs/test.cljs",26,new $APP.h(null,6,[$APP.xD,!0,$APP.tw,2,$APP.VQ,2,$APP.mQ,new $APP.G(null,1,5,$APP.I,[$APP.J($APP.XF,$APP.BN,$APP.BG)],null),$APP.Z,$APP.J(new $APP.G(null,4,5,$APP.I,[$APP.XF,$APP.BN,$APP.jm,$APP.BG],null)),$APP.RI,$APP.J(null)],null),1,310,310,$APP.J(new $APP.G(null,4,5,$APP.I,[$APP.XF,$APP.BN,$APP.jm,$APP.BG],null)),null,$APP.l(D4)?D4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),
$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return G5},RPa,$APP.Rj([$APP.aG,$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.yO,$APP.hp,$APP.bo,$APP.st,$APP.yS,$APP.Z,$APP.M,$APP.XI],["1.1",$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,
$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),AOa,"sci/configs/cljs/test.cljs",17,new $APP.h(null,6,[$APP.xD,!1,$APP.tw,2,$APP.VQ,2,$APP.mQ,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.KM],null),new $APP.G(null,2,5,$APP.I,[$APP.KM,$APP.pQ],null)),$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.KM],null),new $APP.G(null,2,5,$APP.I,[$APP.KM,$APP.pQ],null)),$APP.RI,$APP.J(null,null)],null),1,663,!0,663,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.KM],null),new $APP.G(null,2,5,$APP.I,[$APP.KM,$APP.pQ],null)),"Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n\n  Example: (is (\x3d 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.",
$APP.l(G5)?G5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return u4},oOa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.yO,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,
3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),SOa,"sci/configs/cljs/test.cljs",16,new $APP.h(null,6,[$APP.xD,!1,$APP.tw,1,$APP.VQ,1,$APP.mQ,new $APP.G(null,2,5,$APP.I,[$APP.oi,new $APP.G(null,1,5,$APP.I,[w5],null)],null),$APP.Z,$APP.J($APP.oi,new $APP.G(null,1,5,$APP.I,[w5],null)),$APP.RI,$APP.J(null,null)],null),1,289,289,$APP.J($APP.oi,new $APP.G(null,1,5,$APP.I,[w5],null)),"Generates a testing environment with a reporter.\n   (empty-env) - uses the :cljs.test/default reporter.\n   (empty-env :cljs.test/pprint) - pretty prints all data structures.\n   (empty-env reporter) - uses a reporter of your choosing.\n   To create your own reporter see cljs.test/report",
$APP.l(u4)?u4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return W4},yOa,$APP.Rj([$APP.aG,$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],["1.1",$APP.Ue(r5,new $APP.h(null,
3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),lOa,"sci/configs/cljs/test.cljs",23,1,785,785,$APP.J(new $APP.G(null,2,5,$APP.I,[$APP.Hla,$APP.Ila],null)),"Composes two fixture functions, creating a new fixture function\n  that combines their behavior.",$APP.l(W4)?W4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?
$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return J4},iOa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),fOa,"sci/configs/cljs/test.cljs",16,1,444,444,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.LN],null)),null,$APP.l(J4)?J4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return v4},LPa,$APP.Rj([$APP.W,
$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),EPa,"sci/configs/cljs/test.cljs",22,1,307,307,$APP.J($APP.oi),null,$APP.l(v4)?v4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return L5},VOa,$APP.Rj([$APP.aG,$APP.W,$APP.O,$APP.ao,$APP.VC,
$APP.yO,$APP.hp,$APP.bo,$APP.st,$APP.yS,$APP.Z,$APP.M,$APP.XI],["1.1",$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),qPa,"sci/configs/cljs/test.cljs",23,new $APP.h(null,6,[$APP.xD,!0,$APP.tw,1,$APP.VQ,1,$APP.mQ,$APP.J($APP.J($APP.xF,$APP.UE)),$APP.Z,$APP.J(new $APP.G(null,3,5,$APP.I,[$APP.xF,$APP.jm,$APP.UE],null)),$APP.RI,$APP.J(null)],null),1,754,!0,754,$APP.J(new $APP.G(null,3,5,$APP.I,[$APP.xF,$APP.jm,$APP.UE],null)),"Like deftest but creates a private var.",$APP.l(L5)?L5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),
$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return K4},FPa,$APP.Rj([$APP.aG,$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],["1.1",$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),ZOa,"sci/configs/cljs/test.cljs",16,1,474,474,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.UN],null)),"Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).",$APP.l(K4)?K4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,
b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return J5},COa,$APP.Rj([$APP.aG,$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.yO,$APP.hp,$APP.bo,$APP.st,$APP.yS,$APP.Z,$APP.M,$APP.XI],["1.1",$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),PPa,"sci/configs/cljs/test.cljs",24,new $APP.h(null,6,[$APP.xD,!0,$APP.tw,1,$APP.VQ,1,$APP.mQ,$APP.J($APP.J(q5,$APP.UE)),$APP.Z,$APP.J(new $APP.G(null,3,5,$APP.I,[q5,$APP.jm,$APP.UE],null)),$APP.RI,$APP.J(null)],null),1,724,!0,724,$APP.J(new $APP.G(null,3,5,$APP.I,[q5,$APP.jm,$APP.UE],null)),"Takes any definition form (that returns a Var) as the first argument.\n  Remaining body goes in the :test metadata function for that Var.\n\n  When *load-tests* is false, only evaluates the definition, ignoring\n  the tests.",
$APP.l(J5)?J5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return V4},qOa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.st,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,
3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),ePa,"sci/configs/cljs/test.cljs",23,1,631,!0,631,$APP.J(new $APP.G(null,4,5,$APP.I,[$APP.sN,$APP.lI,$APP.pQ,$APP.KM],null)),"Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.",$APP.l(V4)?V4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,
b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return B4},HPa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),MOa,"sci/configs/cljs/test.cljs",27,1,336,336,$APP.J($APP.oi),"Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces.",$APP.l(B4)?B4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,
b,d)}(),function(){var a=new $APP.ae(function(){return h5},TPa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),GOa,"sci/configs/cljs/test.cljs",22,1,928,928,$APP.J(new $APP.G(null,1,5,$APP.I,[NPa],null)),"Like test-vars, but returns a block for further composition and\n  later execution.",$APP.l(h5)?h5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,
b,d)}(),function(){var a=new $APP.ae(function(){return E4},MPa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),DOa,"sci/configs/cljs/test.cljs",26,1,342,342,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.xF],null)),"Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil.",$APP.l(E4)?E4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?
$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),aQa,function(){var a=new $APP.ae(function(){return K5},VPa,$APP.Rj([$APP.aG,$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.yO,$APP.hp,$APP.bo,$APP.st,$APP.yS,$APP.Z,$APP.M,$APP.XI],["1.1",$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),tPa,"sci/configs/cljs/test.cljs",22,new $APP.h(null,6,[$APP.xD,!0,$APP.tw,1,$APP.VQ,1,$APP.mQ,$APP.J($APP.J($APP.xF,$APP.UE)),$APP.Z,$APP.J(new $APP.G(null,3,5,$APP.I,[$APP.xF,$APP.jm,$APP.UE],null)),$APP.RI,$APP.J(null)],null),1,737,!0,737,$APP.J(new $APP.G(null,3,5,$APP.I,[$APP.xF,$APP.jm,$APP.UE],null)),"Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When *load-tests* is false, deftest is ignored.",
$APP.l(K5)?K5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),bQa,function(){var a=new $APP.ae(function(){return P5},UOa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.yO,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,
3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),yPa,"sci/configs/cljs/test.cljs",16,new $APP.h(null,6,[$APP.xD,!0,$APP.tw,1,$APP.VQ,1,$APP.mQ,new $APP.G(null,2,5,$APP.I,[$APP.oi,new $APP.G(null,1,5,$APP.I,[x5],null)],null),$APP.Z,$APP.J($APP.oi,new $APP.G(null,1,5,$APP.I,[x5],null),new $APP.G(null,3,5,$APP.I,[x5,$APP.jm,iPa],null)),$APP.RI,$APP.J(null,null,null)],null),1,1053,1053,$APP.J($APP.oi,new $APP.G(null,1,5,$APP.I,[x5],null),new $APP.G(null,3,5,$APP.I,[x5,$APP.jm,iPa],null)),"Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given. Does not return a meaningful\n  value due to the possiblity of asynchronous execution. To detect test\n  completion add a :end-run-tests method case to the cljs.test/report\n  multimethod.",
$APP.l(P5)?P5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return Q5},KPa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.yO,$APP.hp,$APP.bo,$APP.st,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,
3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),tOa,"sci/configs/cljs/test.cljs",28,new $APP.h(null,6,[$APP.xD,!1,$APP.tw,2,$APP.VQ,2,$APP.mQ,$APP.J($APP.oi,new $APP.G(null,1,5,$APP.I,[$APP.CG],null),new $APP.G(null,2,5,$APP.I,[$APP.CG,y5],null)),$APP.Z,$APP.J($APP.oi,new $APP.G(null,1,5,$APP.I,[$APP.CG],null),new $APP.G(null,2,5,$APP.I,[$APP.CG,y5],null)),$APP.RI,$APP.J(null,null,null)],null),1,1067,!0,1067,$APP.J($APP.oi,new $APP.G(null,1,5,$APP.I,[$APP.CG],null),new $APP.G(null,2,5,$APP.I,[$APP.CG,y5],null)),"Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.",
$APP.l(Q5)?Q5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),YPa,function(){var a=new $APP.ae(function(){return n5},wOa,$APP.Rj([$APP.W,$APP.O,$APP.It,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,
3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),UPa,!0,"sci/configs/cljs/test.cljs",27,1,1110,1110,$APP.J(new $APP.G(null,3,5,$APP.I,[$APP.sN,$APP.sN,aOa],null)),"Runs a single test.\n  Because the intent is to run a single test, there is no check for the namespace test-ns-hook.",$APP.l(n5)?n5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?
e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),I4,function(){var a=new $APP.ae(function(){return M5},rOa,$APP.Rj([$APP.aG,$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.yO,$APP.hp,$APP.bo,$APP.st,$APP.yS,$APP.Z,$APP.M,$APP.XI],["1.1",$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),$Oa,"sci/configs/cljs/test.cljs",23,new $APP.h(null,6,[$APP.xD,!0,$APP.tw,1,$APP.VQ,1,$APP.mQ,$APP.J($APP.J($APP.xF,$APP.UE)),$APP.Z,$APP.J(new $APP.G(null,3,5,$APP.I,[$APP.xF,$APP.jm,$APP.UE],null)),$APP.RI,$APP.J(null)],null),1,763,!0,763,$APP.J(new $APP.G(null,3,5,$APP.I,[$APP.xF,$APP.jm,$APP.UE],null)),"Experimental.\n  Sets :test metadata of the named var to a fn with the given body.\n  The var must already exist.  Does not modify the value of the var.\n\n  When *load-tests* is false, set-test is ignored.",
$APP.l(M5)?M5.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),D5,function(){var a=new $APP.ae(function(){return $4},vPa,$APP.Rj([$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],[$APP.Ue(r5,new $APP.h(null,3,[A5,
"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),lPa,"sci/configs/cljs/test.cljs",18,1,875,875,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.BN],null)),null,$APP.l($4)?$4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}(),function(){var a=new $APP.ae(function(){return X4},mPa,$APP.Rj([$APP.aG,
$APP.W,$APP.O,$APP.ao,$APP.VC,$APP.hp,$APP.bo,$APP.yS,$APP.Z,$APP.M,$APP.XI],["1.1",$APP.Ue(r5,new $APP.h(null,3,[A5,"Stuart Sierra, with contributions and suggestions by\n  Chas Emerick, Allen Rohner, and Stuart Halloway",$APP.Sx,!0,$APP.M,'A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the "is" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith "abcde" "ab"))\n\n   You can type an "is" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The "expected:" line shows you the original expression, and the\n   "actual:" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   "false" on the last line is the value returned from the\n   expression.  The "is" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   "(is (thrown? c ...))" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0)))\n\n   "(is (thrown-with-msg? c re ...))" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #"Divide by zero"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   "is" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) "Crazy arithmetic")\n\n   In addition, you can document groups of assertions with the\n   "testing" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to "testing" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing "Arithmetic"\n     (testing "with positive integers"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing "with negative integers"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the "testing" macro may only be used\n   INSIDE a "deftest" or "with-test" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The "with-test" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (\x3d 4 (my-function 2 2)))\n     (is (\x3d 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id\x3d51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named "addition" and "subtraction", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s "Practical Common Lisp"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   "(arithmetic addition)", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function "(run-tests namespaces...)":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use "(run-all-tests)".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the "arithmetic" example above, you\n   probably do not want the "addition" and "subtraction" tests run\n   separately.  In that case, you must define a special function\n   named "test-ns-hook" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable "*load-tests*" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by "with-test" or "deftest".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  "each"\n   fixtures are run repeatedly, once for each test function created\n   with "deftest" or "with-test".  "each" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   "each" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a "once" fixture, is only run once,\n   around ALL the tests in the namespace.  "once" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach "once" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the "is" macro by defining new\n   methods for the "assert-expr" multimethod.  These methods are\n   called during expansion of the "is" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the "report" function: (report event)\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The "testing" strings will be a list in "*current-env*", and\n   the vars being tested will be a list in "*testing-vars*".\n\n   Your "report" function should wrap any printing calls in the\n   "with-test-out" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n'],
null)),bOa,"sci/configs/cljs/test.cljs",20,1,792,792,$APP.J(new $APP.G(null,1,5,$APP.I,[DPa],null)),"Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.",$APP.l(X4)?X4.D:null])),b=$APP.q(a),c=$APP.Ve(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.h(null,4,[$APP.W,D5,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.M,$APP.M.g(c)],null);return $APP.l($APP.gu.g(c))?$APP.gV.j(a,b,d):$APP.l(function(){var e=$APP.st.g(c);return $APP.l(e)?e:$APP.It.g(c)}())?
$APP.hV.j(a,b,d):$APP.Mx.j(a,b,d)}()]);$APP.zy(new $APP.h(null,1,[$APP.Ut,new $APP.h(null,1,[$APP.uO,cQa],null)],null));