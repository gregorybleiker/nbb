import { $APP, shadow$provide, $jscomp } from "./nbb_core.js";
const shadow_esm_import = function(x) { return import(x) };
var i6=function(a,b,c,d){return $APP.Ue(new $APP.G(null,2,5,$APP.I,[d,null],null),new $APP.h(null,3,[ZQa,a,$Qa,b,aRa,c],null))},j6=function(a){return a.g?a.g(0):a.call(null,0)},k6=function(a){var b=j6(a);a=ZQa.g($APP.Ve(a));return a.g?a.g(b):a.call(null,b)},l6=function(a){if($APP.l(k6(a))){var b=j6(a);a=$Qa.g($APP.Ve(a));return a.g?a.g(b):a.call(null,b)}throw"called children on a leaf node";},m6=function(a,b,c){a=aRa.g($APP.Ve(a));return a.h?a.h(b,c):a.call(null,b,c)},r6=function(a){if($APP.l(k6(a))){var b=
$APP.A.j(a,0,null),c=$APP.A.j(a,1,null),d=l6(a),e=$APP.u(d),f=$APP.v(e);e=$APP.w(e);return $APP.l(d)?$APP.Ue(new $APP.G(null,2,5,$APP.I,[f,new $APP.h(null,4,[n6,$APP.oi,o6,$APP.l(c)?$APP.Ng.h(o6.g(c),b):new $APP.G(null,1,5,$APP.I,[b],null),p6,c,q6,e],null)],null),$APP.Ve(a)):null}return null},t6=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null),d=$APP.vh(c);c=$APP.C.h(d,n6);var e=$APP.C.h(d,p6),f=$APP.C.h(d,o6),k=$APP.C.h(d,q6);d=$APP.C.h(d,s6);return $APP.l(f)?(f=$APP.We(f),$APP.Ue($APP.l(d)?
new $APP.G(null,2,5,$APP.I,[m6(a,f,$APP.K.h(c,$APP.Rg(b,k))),$APP.l(e)?$APP.kk.j(e,s6,!0):e],null):new $APP.G(null,2,5,$APP.I,[f,e],null),$APP.Ve(a))):null},u6=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);c=$APP.vh(c);var d=$APP.C.h(c,n6),e=$APP.C.h(c,q6),f=$APP.u(e),k=$APP.v(f);f=$APP.w(f);return $APP.l($APP.l(c)?e:c)?$APP.Ue(new $APP.G(null,2,5,$APP.I,[k,$APP.kk.l(c,n6,$APP.Ng.h(d,b),$APP.B([q6,f]))],null),$APP.Ve(a)):null},v6=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);
c=$APP.vh(c);var d=$APP.C.h(c,n6),e=$APP.C.h(c,q6);return $APP.l($APP.l(c)?e:c)?$APP.Ue(new $APP.G(null,2,5,$APP.I,[$APP.Pe(e),$APP.kk.l(c,n6,$APP.Oh.B($APP.Ng,d,b,$APP.wk(e)),$APP.B([q6,null]))],null),$APP.Ve(a)):a},bRa=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);c=$APP.vh(c);var d=$APP.C.h(c,n6),e=$APP.C.h(c,q6);return $APP.l($APP.l(c)?$APP.u(d):c)?$APP.Ue(new $APP.G(null,2,5,$APP.I,[$APP.We(d),$APP.kk.l(c,n6,$APP.Xe(d),$APP.B([q6,$APP.Rg(b,e)]))],null),$APP.Ve(a)):null},w6=function(a,
b){$APP.A.j(a,0,null);var c=$APP.A.j(a,1,null);return $APP.Ue(new $APP.G(null,2,5,$APP.I,[b,$APP.kk.j(c,s6,!0)],null),$APP.Ve(a))},x6=new $APP.t(null,"make-node","make-node",-1550461835,null),cRa=new $APP.t("clojure.zip","append-child","clojure.zip/append-child",-1333956306,null),dRa=new $APP.t(null,"insert-right","insert-right",1842751767,null),eRa=new $APP.t("clojure.zip","insert-child","clojure.zip/insert-child",-210602132,null),fRa=new $APP.t("clojure.zip","end?","clojure.zip/end?",381053413,
null),gRa=new $APP.t(null,"insert-left","insert-left",1917369949,null),hRa=new $APP.t(null,"lefts","lefts",1054400638,null),iRa=new $APP.t("clojure.zip","node","clojure.zip/node",-1345203614,null),jRa=new $APP.t("clojure.zip","edit","clojure.zip/edit",-442418038,null),kRa=new $APP.t("clojure.zip","zipper","clojure.zip/zipper",-571036006,null),y6=new $APP.t(null,"item","item",1889905329,null),lRa=new $APP.t("clojure.zip","next","clojure.zip/next",-1526224397,null),$Qa=new $APP.F("zip","children","zip/children",
-940194589),mRa=new $APP.t(null,"up","up",1370819414,null),nRa=new $APP.t("clojure.zip","branch?","clojure.zip/branch?",-1006947869,null),oRa=new $APP.t("clojure.zip","up","clojure.zip/up",1006365229,null),pRa=new $APP.t("clojure.zip","children","clojure.zip/children",65376544,null),qRa=new $APP.t("clojure.zip","leftmost","clojure.zip/leftmost",-1791272498,null),rRa=new $APP.t(null,"leftmost","leftmost",-1158121305,null),o6=new $APP.F(null,"pnodes","pnodes",1739080565),sRa=new $APP.t(null,"xml-zip",
"xml-zip",-1566989793,null),tRa=new $APP.t("clojure.zip","replace","clojure.zip/replace",413367034,null),uRa=new $APP.t(null,"end?","end?",217139918,null),vRa=new $APP.t("clojure.zip","path","clojure.zip/path",1758958974,null),wRa=new $APP.t("clojure.zip","rightmost","clojure.zip/rightmost",1799140158,null),xRa=new $APP.t("clojure.zip","xml-zip","clojure.zip/xml-zip",-925187274,null),yRa=new $APP.t("clojure.zip","down","clojure.zip/down",1356031458,null),zRa=new $APP.F(null,"content","content",15833224),
aRa=new $APP.F("zip","make-node","zip/make-node",1103800591),ARa=new $APP.t("clojure.zip","seq-zip","clojure.zip/seq-zip",-395973642,null),BRa=new $APP.t("clojure.zip","prev","clojure.zip/prev",-389017676,null),CRa=new $APP.t("clojure.zip","insert-right","clojure.zip/insert-right",194316302,null),DRa=new $APP.t("clojure.zip","vector-zip","clojure.zip/vector-zip",986730862,null),s6=new $APP.F(null,"changed?","changed?",-437828330),ERa=new $APP.t(null,"zipper","zipper",-1153741331,null),FRa=new $APP.t("clojure.zip",
"left","clojure.zip/left",1740332703,null),GRa=new $APP.t(null,"append-child","append-child",-1707191801,null),HRa=new $APP.t("clojure.zip","root","clojure.zip/root",-1119588559,null),IRa=new $APP.t(null,"vector-zip","vector-zip",1075131029,null),JRa=new $APP.t(null,"insert-child","insert-child",347166277,null),KRa=new $APP.t("clojure.zip","remove","clojure.zip/remove",859584278,null),LRa=new $APP.t("clojure.zip","insert-left","clojure.zip/insert-left",1476893044,null),MRa=new $APP.t(null,"rightmost",
"rightmost",-1854156251,null),NRa=new $APP.t("clojure.zip","rights","clojure.zip/rights",1361118051,null),ORa=new $APP.t("clojure.zip","make-node","clojure.zip/make-node",-640223892,null),PRa=new $APP.t(null,"seq-zip","seq-zip",-2034709283,null),QRa=new $APP.t(null,"down","down",-1089190199,null),RRa=new $APP.t(null,"rights","rights",2003591322,null),q6=new $APP.F(null,"r","r",-471384190),n6=new $APP.F(null,"l","l",1395893423),SRa=new $APP.t("clojure.zip","right","clojure.zip/right",-1593586409,null),
p6=new $APP.F(null,"ppath","ppath",-1758182784),ZQa=new $APP.F("zip","branch?","zip/branch?",-998880862),TRa=new $APP.t("clojure.zip","lefts","clojure.zip/lefts",538689815,null);var z6=function z6(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return z6.l(arguments[0],arguments[1],2<c.length?new $APP.ce(c.slice(2),0,null):null)};z6.l=function(a,b,c){return w6(a,$APP.Oh.j(b,j6(a),c))};z6.o=2;z6.A=function(a){var b=$APP.v(a),c=$APP.w(a);a=$APP.v(c);c=$APP.w(c);return this.l(b,a,c)};var URa=$APP.mV.h($APP.zQ,null),VRa=$APP.Ox($APP.Rj([$APP.Ue(ERa,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,4,5,$APP.I,[$APP.gM,$APP.AK,x6,$APP.jP],null))),$APP.M,"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],
null)),$APP.Ue(mRa,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null))),$APP.M,"Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],null)),$APP.Ue($APP.Pta,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null))),$APP.M,"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],null)),$APP.Ue(dRa,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,
2,5,$APP.I,[$APP.dS,y6],null))),$APP.M,"Inserts the item as the right sibling of the node at this loc,\n  without moving"],null)),$APP.Ue(gRa,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,2,5,$APP.I,[$APP.dS,y6],null))),$APP.M,"Inserts the item as the left sibling of the node at this loc,\n without moving"],null)),$APP.Ue(uRa,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null))),$APP.M,"Returns true if loc represents the end of a depth-first walk"],
null)),$APP.Ue($APP.wH,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null))),$APP.M,"Returns the node at loc"],null)),$APP.Ue($APP.OR,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,2,5,$APP.I,[$APP.dS,$APP.wH],null))),$APP.M,"Replaces the node at this loc, without moving"],null)),$APP.Ue($APP.mla,new $APP.h(null,3,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,4,5,$APP.I,[$APP.dS,$APP.BN,$APP.jm,$APP.DG],null))),$APP.M,"Replaces the node at this loc with the value of (f node args)",
$APP.xO,new $APP.h(null,6,[$APP.AD,!0,$APP.tw,2,$APP.UQ,2,$APP.kQ,new $APP.G(null,1,5,$APP.I,[$APP.J($APP.dS,$APP.BN,$APP.DG)],null),$APP.Z,$APP.J(new $APP.G(null,4,5,$APP.I,[$APP.dS,$APP.BN,$APP.jm,$APP.DG],null)),$APP.QI,$APP.J(null)],null)],null)),$APP.Ue(PRa,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.jP],null))),$APP.M,"Returns a zipper for nested sequences, given a root sequence"],null)),$APP.Ue($APP.KO,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,
1,5,$APP.I,[$APP.dS],null))),$APP.M,"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],null)),$APP.Ue(sRa,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.jP],null))),$APP.M,"Returns a zipper for xml elements (as from xml/parse),\n  given a root element"],null)),$APP.Ue(IRa,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,
[$APP.jP],null))),$APP.M,"Returns a zipper for nested vectors, given a root vector"],null)),$APP.Ue(x6,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,3,5,$APP.I,[$APP.dS,$APP.wH,$APP.AK],null))),$APP.M,"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],null)),$APP.Ue($APP.gM,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null))),$APP.M,"Returns true if the node at loc is a branch"],
null)),$APP.Ue($APP.uja,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null))),$APP.M,"Returns the loc of the right sibling of the node at this loc, or nil"],null)),$APP.Ue($APP.Osa,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null))),$APP.M,"Returns a seq of nodes leading to this loc"],null)),$APP.Ue($APP.jP,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null))),$APP.M,"zips all the way up and returns the root node, reflecting any\n changes."],
null)),$APP.Ue(RRa,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null))),$APP.M,"Returns a seq of the right siblings of this loc"],null)),$APP.Ue($APP.AK,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null))),$APP.M,"Returns a seq of the children of node at loc, which must be a branch"],null)),$APP.Ue(rRa,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null))),$APP.M,"Returns the loc of the leftmost sibling of the node at this loc, or self"],
null)),$APP.Ue(QRa,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null))),$APP.M,"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],null)),$APP.Ue($APP.bra,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null))),$APP.M,"Returns the loc of the left sibling of the node at this loc, or nil"],null)),$APP.Ue(hRa,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],
null))),$APP.M,"Returns a seq of the left siblings of this loc"],null)),$APP.Ue(JRa,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,2,5,$APP.I,[$APP.dS,y6],null))),$APP.M,"Inserts the item as the leftmost child of the node at this loc,\n  without moving"],null)),$APP.Ue(GRa,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,2,5,$APP.I,[$APP.dS,y6],null))),$APP.M,"Inserts the item as the rightmost child of the node at this loc,\n  without moving"],null)),$APP.Ue(MRa,new $APP.h(null,
2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null))),$APP.M,"Returns the loc of the rightmost sibling of the node at this loc, or self"],null)),$APP.Ue($APP.zD,new $APP.h(null,2,[$APP.Z,$APP.J($APP.zm,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null))),$APP.M,"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],null))],[new $APP.h(null,3,[$APP.O,kRa,$APP.Nx,i6,$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,4,5,$APP.I,
[$APP.gM,$APP.AK,x6,$APP.jP],null)),$APP.M,"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],null)],null),new $APP.h(null,3,[$APP.O,oRa,$APP.Nx,t6,$APP.yb,new $APP.h(null,
2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],null)],null),new $APP.h(null,3,[$APP.O,BRa,$APP.Nx,function(a){var b=bRa(a);if($APP.l(b))for(a=b;;)if(b=k6(a),b=$APP.l(b)?r6(a):b,$APP.l(b))a=v6(b);else return a;else return t6(a)},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],
null)],null),new $APP.h(null,3,[$APP.O,CRa,$APP.Nx,function(a,b){var c=$APP.A.j(a,0,null),d=$APP.A.j(a,1,null);d=$APP.vh(d);var e=$APP.C.h(d,q6);if(null==d)throw"Insert at top";return $APP.Ue(new $APP.G(null,2,5,$APP.I,[c,$APP.kk.l(d,q6,$APP.Rg(b,e),$APP.B([s6,!0]))],null),$APP.Ve(a))},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,2,5,$APP.I,[$APP.dS,y6],null)),$APP.M,"Inserts the item as the right sibling of the node at this loc,\n  without moving"],null)],null),new $APP.h(null,3,[$APP.O,
LRa,$APP.Nx,function(a,b){var c=$APP.A.j(a,0,null),d=$APP.A.j(a,1,null);d=$APP.vh(d);var e=$APP.C.h(d,n6);if(null==d)throw"Insert at top";return $APP.Ue(new $APP.G(null,2,5,$APP.I,[c,$APP.kk.l(d,n6,$APP.Ng.h(e,b),$APP.B([s6,!0]))],null),$APP.Ve(a))},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,2,5,$APP.I,[$APP.dS,y6],null)),$APP.M,"Inserts the item as the left sibling of the node at this loc,\n without moving"],null)],null),new $APP.h(null,3,[$APP.O,fRa,$APP.Nx,function(a){return $APP.x.h($APP.XK,
a.g?a.g(1):a.call(null,1))},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"Returns true if loc represents the end of a depth-first walk"],null)],null),new $APP.h(null,3,[$APP.O,iRa,$APP.Nx,j6,$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"Returns the node at loc"],null)],null),new $APP.h(null,3,[$APP.O,tRa,$APP.Nx,w6,$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,2,5,$APP.I,[$APP.dS,$APP.wH],null)),
$APP.M,"Replaces the node at this loc, without moving"],null)],null),new $APP.h(null,3,[$APP.O,jRa,$APP.Nx,z6,$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,4,5,$APP.I,[$APP.dS,$APP.BN,$APP.jm,$APP.DG],null)),$APP.M,"Replaces the node at this loc with the value of (f node args)"],null)],null),new $APP.h(null,3,[$APP.O,ARa,$APP.Nx,function(a){return i6($APP.of,$APP.Mf,function(b,c){return $APP.Ue(c,$APP.Ve(b))},a)},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.jP],
null)),$APP.M,"Returns a zipper for nested sequences, given a root sequence"],null)],null),new $APP.h(null,3,[$APP.O,lRa,$APP.Nx,function(a){if($APP.x.h($APP.XK,a.g?a.g(1):a.call(null,1)))return a;var b=k6(a);b=$APP.l(b)?r6(a):b;if($APP.l(b))return b;b=u6(a);if($APP.l(b))return b;for(;;)if($APP.l(t6(a))){b=u6(t6(a));if($APP.l(b))return b;a=t6(a)}else return new $APP.G(null,2,5,$APP.I,[j6(a),$APP.XK],null)},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,
"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],null)],null),new $APP.h(null,3,[$APP.O,xRa,$APP.Nx,function(a){return i6($APP.Ph($APP.Sb),$APP.yt.h($APP.u,zRa),function(b,c){return $APP.kk.j(b,zRa,$APP.l(c)?$APP.Oh.h($APP.jA,c):c)},a)},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.jP],null)),$APP.M,"Returns a zipper for xml elements (as from xml/parse),\n  given a root element"],
null)],null),new $APP.h(null,3,[$APP.O,DRa,$APP.Nx,function(a){return i6($APP.ff,$APP.u,function(b,c){return $APP.Ue($APP.Ii(c),$APP.Ve(b))},a)},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.jP],null)),$APP.M,"Returns a zipper for nested vectors, given a root vector"],null)],null),new $APP.h(null,3,[$APP.O,ORa,$APP.Nx,m6,$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,3,5,$APP.I,[$APP.dS,$APP.wH,$APP.AK],null)),$APP.M,"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],
null)],null),new $APP.h(null,3,[$APP.O,nRa,$APP.Nx,k6,$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"Returns true if the node at loc is a branch"],null)],null),new $APP.h(null,3,[$APP.O,SRa,$APP.Nx,u6,$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"Returns the loc of the right sibling of the node at this loc, or nil"],null)],null),new $APP.h(null,3,[$APP.O,vRa,$APP.Nx,function(a){return o6.g(a.g?a.g(1):a.call(null,
1))},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"Returns a seq of nodes leading to this loc"],null)],null),new $APP.h(null,3,[$APP.O,HRa,$APP.Nx,function(a){for(;;){if($APP.x.h($APP.XK,a.g?a.g(1):a.call(null,1)))return j6(a);var b=t6(a);if($APP.l(b))a=b;else return j6(a)}},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"zips all the way up and returns the root node, reflecting any\n changes."],null)],null),
new $APP.h(null,3,[$APP.O,NRa,$APP.Nx,function(a){return q6.g(a.g?a.g(1):a.call(null,1))},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"Returns a seq of the right siblings of this loc"],null)],null),new $APP.h(null,3,[$APP.O,pRa,$APP.Nx,l6,$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"Returns a seq of the children of node at loc, which must be a branch"],null)],null),new $APP.h(null,3,[$APP.O,qRa,$APP.Nx,
function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);c=$APP.vh(c);var d=$APP.C.h(c,n6),e=$APP.C.h(c,q6);return $APP.l($APP.l(c)?$APP.u(d):c)?$APP.Ue(new $APP.G(null,2,5,$APP.I,[$APP.v(d),$APP.kk.l(c,n6,$APP.oi,$APP.B([q6,$APP.K.l($APP.ge(d),new $APP.G(null,1,5,$APP.I,[b],null),$APP.B([e]))]))],null),$APP.Ve(a)):a},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"Returns the loc of the leftmost sibling of the node at this loc, or self"],null)],null),
new $APP.h(null,3,[$APP.O,yRa,$APP.Nx,r6,$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],null)],null),new $APP.h(null,3,[$APP.O,FRa,$APP.Nx,bRa,$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"Returns the loc of the left sibling of the node at this loc, or nil"],null)],null),new $APP.h(null,3,[$APP.O,TRa,$APP.Nx,function(a){return $APP.u(n6.g(a.g?
a.g(1):a.call(null,1)))},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"Returns a seq of the left siblings of this loc"],null)],null),new $APP.h(null,3,[$APP.O,eRa,$APP.Nx,function(a,b){return w6(a,m6(a,j6(a),$APP.Rg(b,l6(a))))},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,2,5,$APP.I,[$APP.dS,y6],null)),$APP.M,"Inserts the item as the leftmost child of the node at this loc,\n  without moving"],null)],null),new $APP.h(null,3,[$APP.O,cRa,$APP.Nx,
function(a,b){return w6(a,m6(a,j6(a),$APP.K.h(l6(a),new $APP.G(null,1,5,$APP.I,[b],null))))},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,2,5,$APP.I,[$APP.dS,y6],null)),$APP.M,"Inserts the item as the rightmost child of the node at this loc,\n  without moving"],null)],null),new $APP.h(null,3,[$APP.O,wRa,$APP.Nx,v6,$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"Returns the loc of the rightmost sibling of the node at this loc, or self"],null)],
null),new $APP.h(null,3,[$APP.O,KRa,$APP.Nx,function(a){$APP.A.j(a,0,null);var b=$APP.A.j(a,1,null);b=$APP.vh(b);var c=$APP.C.h(b,n6),d=$APP.C.h(b,p6),e=$APP.C.h(b,o6),f=$APP.C.h(b,q6);if(null==b)throw"Remove at top";if(0<$APP.Ge(c))for(a=$APP.Ue(new $APP.G(null,2,5,$APP.I,[$APP.We(c),$APP.kk.l(b,n6,$APP.Xe(c),$APP.B([s6,!0]))],null),$APP.Ve(a));;)if(b=k6(a),b=$APP.l(b)?r6(a):b,$APP.l(b))a=v6(b);else return a;else return $APP.Ue(new $APP.G(null,2,5,$APP.I,[m6(a,$APP.We(e),f),$APP.l(d)?$APP.kk.j(d,
s6,!0):d],null),$APP.Ve(a))},$APP.yb,new $APP.h(null,2,[$APP.Z,$APP.J(new $APP.G(null,1,5,$APP.I,[$APP.dS],null)),$APP.M,"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],null)],null)]),URa);$APP.zy(new $APP.h(null,1,[$APP.Ut,new $APP.h(null,1,[$APP.zQ,VRa],null)],null));